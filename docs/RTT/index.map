{"version":3,"sources":["node_modules/az/dist/az.js","dicts/swear.js","dicts/drags.js","dicts/gods.js","dicts/racism.js","index.js"],"names":["array","module","exports","clear","ru","filter","x","includes","Az","require","swear","drags","gods","racism","UNIQ_MARKERS","TRIGGERS","sentence_seq","AzInitiated","Analysis","sentence","Promise","resolve","reject","push","params","sentences","replace","split","sentences_tokens","s","Tokens","done","type","marker_collection","triggered_collection","sentences_morphs","sentence_tokens","sentence_morphs","token","morph","Morph","toString","morph_POST","length","tag","POST","text","toLowerCase","is_drags","is_swear","is_god","is_racism","normalized","normalize","word","is_dangerous_people","all_morphs","concat","apply","trigger","no_words_like_this","check_scope","check","CheckMorphsForTriggers","markers","triggered","nw","v","i","a","findIndex","t","morphs","markers_collection","strict_word_sequence","strict_word_direction","words","b","m","b_keys","_b","_a","a_keys","Object","keys","b_key","keys_to_check","valid_keys","need_valid_keys","key","Init","triggers","uniq_markers","loadedAz","init","resolveAnalysis","slice"],"mappings":";;;;;;AAw6EA,IAAA,EAAA,EAAA,UAAA,GAAA,EAAA,+DAx6EA,SAAA,EAAA,GACA,iBAAA,SAAA,oBAAA,OAAA,OAAA,QAAA,IACA,mBAAA,GAAA,EAAA,IAAA,EAAA,KAAA,GACA,EAAA,GAAA,IAHA,CAIA,KAAA,WAAA,aAEA,GAAA,oBAAA,SAAA,iBAAA,SAAA,oBAAA,OACA,IAAA,EAAA,QAAA,MAwDA,MArDA,CACA,KAAA,SAAA,EAAA,EAAA,GACA,GAAA,EACA,EAAA,SAAA,EAAA,CAAA,SAAA,QAAA,EAAA,OAAA,MAAA,SAAA,EAAA,GACA,GAAA,EACA,EAAA,QAIA,GAAA,QAAA,EACA,EAAA,KAAA,KAAA,MAAA,SAEA,GAAA,eAAA,EACA,GAAA,EAAA,OACA,EAAA,KAAA,EAAA,YACA,CAGA,IAFA,IAAA,EAAA,IAAA,YAAA,EAAA,QACA,EAAA,IAAA,WAAA,GACA,EAAA,EAAA,EAAA,EAAA,SAAA,EACA,EAAA,GAAA,EAAA,GAEA,EAAA,KAAA,QAGA,EAAA,IAAA,MAAA,+BAtBA,CA4BA,IAAA,EAAA,IAAA,eACA,EAAA,KAAA,MAAA,GAAA,GACA,EAAA,aAAA,EAEA,EAAA,OAAA,SAAA,GACA,EAAA,UACA,GAAA,EAAA,KAAA,EAAA,WAIA,EAAA,KAAA,QAEA,OAAA,WAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,UAAA,OAAA,IACA,IAAA,IAAA,KAAA,UAAA,GACA,EAAA,GAAA,UAAA,GAAA,GAGA,OAAA,MAOA,SAAA,EAAA,GACA,iBAAA,SAAA,oBAAA,QAAA,OAAA,QAAA,OAAA,SAAA,MAAA,OAAA,QAAA,KAAA,EAAA,OAAA,UACA,mBAAA,GAAA,EAAA,IAAA,EAAA,UAAA,CAAA,MAAA,IACA,EAAA,GAAA,EAAA,IAAA,MAAA,EAAA,GAAA,KAAA,EAAA,EAAA,KAHA,CAIA,KAAA,SAAA,GAAA,aACA,IAEA,EAAA,WACA,EAAA,IACA,EAAA,IAEA,EAAA,GAAA,GAEA,EAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,GACA,GAAA,GAAA,GAAA,GAAA,GAAA,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,IAAA,IAAA,KAAA,IACA,KAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KAAA,IAAA,IAAA,IAAA,IAAA,IACA,IAAA,IAAA,KAAA,IAAA,IAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IACA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,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,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,MAEA,IADA,IACA,EAAA,KAAA,OAAA,QAAA,EAAA,KAAA,OAAA,GAAA,EAAA,KAAA,SACA,IAEA,OAAA,EAAA,KAAA,OAAA,QACA,IACA,KAAA,MAAA,GAEA,KAAA,OAAA,IAEA,MAUA,EAAA,UAAA,WAAA,WACA,IAAA,EAAA,KAAA,WAAA,EAAA,CAAA,UAAA,GACA,OAAA,GAAA,SAAA,EAAA,MAAA,GAcA,EAAA,UAAA,UAAA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,MAEA,IADA,IACA,GAAA,GAAA,EAAA,KAAA,OAAA,GAAA,EAAA,KAAA,SACA,IAEA,OAAA,GAAA,GACA,IACA,KAAA,MAAA,GAEA,KAAA,OAAA,IAEA,MAUA,EAAA,UAAA,YAAA,WACA,IAAA,EAAA,KAAA,WAAA,EAAA,CAAA,UAAA,GACA,OAAA,GAAA,SAAA,EAAA,MAAA,GAWA,EAAA,UAAA,eAAA,SAAA,EAAA,GACA,OAAA,MAAA,KAAA,WAAA,EAAA,EAAA,IAWA,EAAA,UAAA,gBAAA,SAAA,EAAA,GACA,OAAA,MAAA,KAAA,WAAA,EAAA,EAAA,IAGA;;ACt6EA,IAAIA,EAAQ,CAAO,GAAA,CACf,UACA,QACA,OACA,aACA,QACA,QACA,WACA,YACA,SACA,WACA,OACA,QACA,cACA,QACA,OACA,UACA,SACA,UACA,QACA,cACA,SACA,QACA,SACA,SACA,UACA,WACA,aACA,cACA,QACA,OACA,SACA,QACA,YACA,SACA,OACA,UACA,SACA,aACA,WACA,SACA,WACA,YACA,QACA,YACA,QACA,WACA,UACA,QACA,WACA,UACA,aACA,UACA,WACA,iBACA,QACA,aACA,QACA,UACA,WACA,eACA,WACA,OACA,aACA,wBACA,UACA,UACA,QACA,UACA,SACA,YACA,YACA,UACA,WACA,QACA,SACA,UACA,UACA,WACA,eACA,WACA,gBACA,OACA,QACA,YACA,YACA,YACA,OACA,cACA,WACA,QACA,WACA,OACA,YACA,QACA,WACA,OACA,QACA,UACA,UACA,OACA,QACA,SACA,UACA,UACA,OACA,SACA,cACA,WACA,QACA,iBACA,UACA,SACA,SACA,QACA,SACA,aACA,OACA,OACA,aACA,SACA,cACA,WACA,QACA,OACA,WACA,eACA,aACA,UACA,cACA,WACA,YACA,UACA,aACA,iBACA,SACA,WACA,SACA,OACA,OACA,QACA,QACA,YACA,WACA,MACA,sBACA,QACA,SACA,UACA,YACA,MACA,YACA,SACA,WACA,cACA,UACA,YACA,MACA,aACA,SACA,UACA,QACA,QACA,SACA,UACA,UACA,aACA,YACA,WACA,UACA,YACA,QACA,QACA,WACA,WACA,SACA,UACA,UACA,QACA,SACA,QACA,YACA,SACA,aACA,cACA,WACA,YACA,QACA,WACA,QACA,QACA,cACA,UACA,SACA,QACA,WACA,aACA,SACA,OACA,QACA,aACA,WACA,QACA,YACA,cACA,WACA,YACA,WACA,eACA,UACA,cACA,SACA,WACA,aACA,cACA,MACA,OACA,QACA,eACA,SACA,WACA,YACA,UACA,QACA,aACA,WACA,aACA,UACA,SACA,QACA,UACA,YACA,UACA,UACA,QACA,UACA,MACA,MACA,SACA,QACA,cACA,QACA,iBACA,UACA,QACA,UACA,UACA,UACA,QACA,aACA,WACA,cACA,aACA,WACA,SACA,SACA,OACA,YACA,UACA,SACA,cACA,SACA,UACA,SACA,WACA,UACA,aACA,OACA,eACA,YACA,SACA,WACA,UACA,WACA,YACA,gBACA,QACA,OACA,cACA,aACA,WACA,QACA,cACA,SACA,WACA,UACA,UACA,YACA,YACA,YACA,QACA,QACA,SACA,YACA,OACA,YACA,UACA,aACA,UACA,QACA,cACA,cACA,aACA,UACA,OACA,iBACA,QACA,YACA,SACA,eACA,aACA,QACA,aACA,UACA,WACA,WACA,QACA,SACA,UACA,SACA,SACA,UACA,QACA,WACA,YACA,WACA,aACA,SACA,SACA,QACA,QACA,SACA,QACA,QACA,WACA,WACA,SACA,YACA,aACA,cACA,QACA,SACA,SACA,WACA,aACA,UACA,QACA,QACA,SACA,QACA,UACA,YACA,aACA,aACA,aACA,YACA,WACA,aACA,WACA,cACA,SACA,WACA,cACA,UACA,QACA,QACA,WACA,OACA,MACA,MACA,UACA,UACA,YAGJC,OAAOC,QAAU,WACVC,OADiB,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GACHH,EAAMI,GAAGC,OAAO,SAAAC,GAAG,OAACA,EAAEC,SAAS,OACzCP,EAAMI;;ACvXjB,IAAIJ,EAAQ,CACR,SACA,SACA,OACA,OACA,MACA,WACA,cACA,cACA,SACA,UACA,QACA,QACA,QACA,WACA,UACA,SACA,QACA,OACA,OACA,WACA,OACA,eACA,QACA,WACA,UACA,YACA,QACA,YACA,QACA,UACA,UACA,OACA,QACA,MACA,OACA,YACA,QACA,QACA,QACA,QACA,QACA,QACA,OACA,OACA,WACA,QACA,QACA,gBACA,SACA,gBACA,SACA,QACA,YACA,OACA,aACA,MACA,QACA,SACA,SACA,MACA,QACA,QACA,SACA,QACA,MACA,QACA,SACA,QACA,SACA,QACA,WACA,SACA,OACA,OACA,UACA,SACA,UACA,QACA,OACA,SACA,QACA,OACA,WACA,WACA,UACA,cACA,SACA,QACA,WACA,WACA,aACA,OACA,OACA,OACA,SACA,QACA,UACA,WACA,WACA,UACA,SACA,SACA,QACA,QACA,OACA,QACA,OACA,OACA,aACA,OACA,WACA,QACA,WACA,SACA,WACA,WACA,MACA,UACA,SACA,QACA,UACA,SACA,QACA,SACA,OACA,OACA,SACA,UACA,UACA,MACA,SACA,UACA,OACA,YACA,UACA,OACA,QACA,WACA,OACA,QACA,QACA,QACA,SACA,SACA,WACA,SACA,SACA,SACA,WACA,QACA,YACA,OACA,YACA,QACA,UACA,aACA,SACA,YACA,UACA,QACA,SACA,WACA,QACA,QACA,QACA,SACA,YACA,QACA,UACA,SACA,QACA,QACA,QACA,UACA,OACA,SACA,QACA,QACA,SACA,cACA,UACA,aACA,QACA,QACA,OACA,WACA,QACA,OACA,aACA,QACA,SACA,SACA,aACA,OACA,OACA,OACA,QACA,QACA,MACA,eACA,WACA,UACA,SACA,SACA,SACA,aACA,WACA,QACA,YACA,aACA,YACA,cACA,WACA,cACA,SACA,OACA,QACA,SACA,SACA,UACA,SACA,QACA,QACA,QACA,QACA,UACA,OACA,UACA,SACA,QACA,QACA,OACA,aACA,QACA,QACA,YACA,aACA,cACA,WACA,aACA,YACA,SACA,SACA,YACA,cACA,WACA,UACA,SACA,SACA,UACA,WACA,UACA,cACA,aACA,eACA,cACA,UACA,aACA,eACA,eACA,QACA,eACA,UACA,QACA,WACA,YACA,WACA,SACA,WACA,YACA,YACA,YACA,SACA,WACA,gBACA,WACA,YACA,aACA,YACA,aACA,aACA,WACA,YACA,YACA,OACA,WACA,SACA,SACA,WACA,UACA,MACA,UACA,UACA,cACA,eACA,QACA,UACA,cACA,OACA,QACA,UACA,QACA,QACA,OACA,QACA,QACA,eACA,OACA,QACA,SACA,SACA,QACA,WACA,UACA,UACA,SACA,UACA,QACA,SACA,YACA,QACA,YACA,OACA,UACA,QACA,SACA,SACA,QACA,MACA,UACA,SACA,QACA,OACA,UACA,UACA,QACA,QACA,SACA,UACA,QACA,SACA,QACA,YACA,QACA,UACA,OACA,WACA,QACA,SACA,QACA,QACA,SACA,UACA,YACA,UACA,WACA,UACA,QACA,QACA,WACA,WACA,WACA,MACA,MACA,UACA,YACA,SACA,WACA,OACA,SACA,SACA,YACA,WACA,WACA,WACA,YACA,WACA,UACA,QACA,YACA,UACA,MACA,OACA,QACA,WACA,aACA,UACA,OACA,YACA,UACA,YACA,QACA,QACA,SACA,QACA,SACA,WACA,OACA,YACA,SACA,OACA,SACA,SACA,aACA,cACA,YACA,OACA,QACA,YACA,QACA,WACA,QACA,MACA,UACA,UACA,MACA,OACA,OACA,SACA,UACA,QACA,YACA,WACA,SACA,YACA,WACA,UACA,WACA,QACA,QACA,SACA,QACA,OACA,UACA,SACA,WACA,WACA,eACA,QACA,UACA,UACA,aACA,WACA,UACA,QACA,WACA,UACA,YACA,WACA,SACA,QACA,WACA,UACA,SACA,QACA,OACA,SACA,YACA,aACA,WACA,WACA,OACA,WACA,SACA,UACA,OACA,YACA,OACA,OACA,QACA,SACA,UACA,UACA,UACA,YACA,UACA,UACA,QAGJC,OAAOC,QAAU,WACNF,OAAAA;;ACpeX,IAAIA,EAAQ,CACR,YACA,UACA,UACA,QACA,SACA,QACA,SACA,WACA,YACA,WACA,SACA,aACA,OACA,WACA,OACA,OACA,QACA,SACA,SACA,QACA,WACA,SACA,aACA,OACA,OACA,OACA,UACA,SACA,OACA,OACA,QACA,aACA,YACA,YACA,UACA,SACA,QACA,QACA,QACA,SACA,SACA,YACA,UACA,UACA,aACA,UACA,WACA,OACA,aACA,YACA,QACA,SACA,SACA,OACA,SACA,aACA,UACA,SACA,OACA,SACA,YACA,UACA,SACA,SACA,QACA,OACA,OACA,OACA,QACA,UACA,OACA,OACA,UACA,OACA,WACA,OACA,aACA,aACA,OACA,QACA,UACA,OACA,cACA,iBACA,UACA,WACA,QACA,QACA,UACA,WACA,OACA,QACA,UACA,SACA,SACA,SACA,YACA,SACA,YACA,SACA,OACA,UACA,QACA,OACA,QACA,OACA,YACA,QACA,WACA,SACA,SACA,aACA,SACA,QACA,QACA,OACA,OACA,OACA,OACA,WACA,SACA,YACA,cACA,QACA,WACA,UACA,OACA,OACA,QACA,UACA,QACA,OACA,aACA,SACA,QACA,QACA,SACA,UACA,eACA,aACA,QACA,OACA,QACA,eACA,QACA,aACA,QACA,UACA,eACA,OACA,SACA,WACA,OACA,SACA,SACA,SACA,OACA,OACA,QACA,SACA,OACA,SACA,QACA,SACA,kBACA,SACA,QACA,WACA,QACA,OACA,OACA,WACA,cACA,YACA,QACA,UACA,WACA,UACA,YACA,OACA,SACA,WACA,YACA,UACA,OACA,aACA,SACA,OACA,SACA,OACA,UACA,SACA,SACA,OACA,QACA,aACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,UACA,UACA,WACA,cACA,SACA,SACA,QACA,SACA,OACA,UACA,WACA,OACA,QACA,UACA,aACA,QACA,OACA,YACA,OACA,gBACA,QACA,SACA,UACA,SACA,UACA,QACA,UACA,SACA,WACA,YACA,OACA,QACA,OACA,QACA,SACA,OACA,SACA,WACA,QACA,cACA,UACA,SACA,UACA,OACA,YACA,OACA,SACA,SACA,YACA,QACA,OACA,aACA,QACA,eACA,QACA,OACA,WACA,WACA,SACA,QACA,SACA,eACA,SACA,iBACA,aACA,WACA,OACA,QACA,UACA,SACA,OACA,OACA,QACA,QACA,QACA,OACA,YACA,aACA,QACA,QACA,SACA,QACA,UACA,QACA,SACA,cACA,UACA,QACA,QACA,UACA,aACA,YACA,SACA,OACA,aACA,SACA,YACA,QACA,SACA,WACA,SACA,OACA,OACA,QACA,OACA,WACA,YACA,QACA,OACA,gBACA,UACA,WACA,SACA,SACA,SACA,aACA,SACA,OACA,UACA,OACA,OACA,gBACA,QACA,SACA,OACA,OACA,SACA,aACA,YACA,UACA,QACA,YACA,QACA,cACA,YACA,YACA,OACA,eACA,QACA,WACA,SACA,OACA,SACA,UACA,SACA,SACA,QACA,SACA,WACA,SACA,QACA,UACA,YACA,UACA,QACA,QACA,gBACA,WACA,OACA,UACA,OACA,SACA,OACA,UACA,SACA,WACA,OACA,WACA,QACA,OACA,SACA,OACA,OACA,QACA,OACA,SACA,QACA,UACA,WACA,UACA,QACA,eACA,OACA,OACA,WACA,QACA,UACA,WACA,OACA,QACA,aACA,SACA,YACA,OACA,SACA,aACA,UACA,SACA,OACA,OACA,SACA,UACA,UACA,OACA,SACA,UACA,UACA,YACA,aACA,WACA,WACA,SACA,QACA,SACA,SACA,iBACA,UACA,QACA,YACA,OACA,YACA,aACA,SACA,YACA,OACA,QACA,SACA,QACA,QACA,WACA,QACA,SACA,SACA,OACA,OACA,OACA,QACA,YACA,OACA,QACA,QACA,eACA,YACA,SACA,OACA,SACA,QACA,WACA,QACA,cACA,QACA,SACA,SACA,QACA,QACA,WACA,QACA,WACA,UACA,SACA,WACA,OACA,SACA,WACA,aACA,SACA,UACA,SACA,OACA,QACA,SACA,OACA,QACA,UACA,QACA,QACA,QACA,OACA,OACA,OACA,QACA,YACA,WACA,YACA,OACA,OACA,SACA,UACA,QACA,SACA,SACA,QACA,UACA,UACA,SACA,UACA,UACA,SACA,WACA,OACA,aACA,UACA,YACA,QACA,YACA,OACA,OACA,WACA,WACA,OACA,QACA,OACA,SACA,QACA,WACA,OACA,YACA,QACA,QACA,SACA,SACA,WACA,QACA,eACA,SACA,SACA,QACA,OACA,UACA,QACA,SACA,WACA,YACA,QACA,aACA,aACA,QACA,SACA,eACA,WACA,SACA,SACA,OACA,QACA,SACA,QACA,UACA,aACA,OACA,OACA,QACA,QACA,OACA,QACA,QACA,WACA,OACA,YACA,QACA,UACA,QACA,OACA,UACA,oBACA,UACA,OACA,QACA,WACA,UACA,QACA,UACA,UACA,OACA,UACA,QACA,YACA,QACA,SACA,SACA,WACA,WACA,QACA,WACA,aACA,QACA,SACA,SACA,WACA,OACA,gBACA,UACA,SACA,QACA,QACA,QACA,SACA,UACA,WACA,OACA,eACA,aACA,aACA,WACA,SACA,SACA,SACA,QACA,OACA,SACA,QACA,UACA,OACA,SACA,SACA,QACA,OACA,QACA,UACA,OACA,UACA,QACA,UACA,UACA,QACA,SACA,UACA,WACA,OACA,YACA,OACA,UACA,WACA,QACA,UACA,QACA,cACA,UACA,SACA,UACA,gBACA,WACA,WACA,SACA,SACA,SACA,UACA,YACA,eACA,SACA,eACA,SACA,SACA,QACA,WACA,YACA,SACA,eACA,eACA,QACA,eACA,SACA,WACA,UACA,OACA,OACA,UACA,WACA,iBACA,QACA,SACA,aACA,OACA,UACA,cACA,OACA,QACA,OACA,SACA,UACA,OACA,SACA,QACA,eACA,eACA,OACA,OACA,UACA,OACA,OACA,SACA,OACA,QACA,OACA,SACA,cACA,aACA,OACA,UACA,QACA,SACA,OACA,OACA,UACA,aACA,SACA,UACA,QACA,SACA,UACA,UACA,SACA,QACA,OACA,cACA,QACA,UACA,SACA,QACA,QACA,UACA,QACA,OACA,OACA,QACA,WACA,SACA,SACA,kBACA,SACA,WACA,WACA,YACA,SACA,QACA,QACA,QACA,UACA,SACA,OACA,iBACA,UACA,OACA,UACA,QACA,WACA,OACA,SACA,SACA,QACA,SACA,UACA,YACA,SACA,WACA,WACA,UACA,UACA,gBACA,UACA,QACA,SACA,UACA,WACA,YACA,UACA,WACA,QACA,QACA,WACA,QACA,UACA,OACA,SACA,UACA,aACA,YACA,QACA,UACA,OACA,QACA,UACA,UACA,OACA,UACA,SACA,UACA,OACA,SACA,SACA,WACA,YACA,WACA,SACA,QACA,OACA,aACA,SACA,SACA,SACA,SACA,OACA,QACA,OACA,QACA,OACA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,QACA,SACA,QACA,UACA,aACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,cAGJC,OAAOC,QAAU,WACNF,OAAAA;;ACj0BX,IAAIA,EAAQ,CACR,QACA,QACA,WACA,QACA,aACA,QACA,aACA,SACA,UACA,UACA,WACA,YACA,OACA,SAGJC,OAAOC,QAAU,WACNF,OAAAA;;ACoNX,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,mDAAA,SAAA,EAAA,GAAA,GAAA,OAAA,YAAA,OAAA,IAAA,uBAAA,OAAA,UA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","file":"index.map","sourceRoot":"../..","sourcesContent":[";(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define('Az', factory) :\n  global.Az = factory()\n}(this, function () { 'use strict';\n  /** @namespace Az **/\n  if (typeof require != 'undefined' && typeof exports === 'object' && typeof module !== 'undefined') {\n    var fs = require('fs');\n  }\n\n  var Az = {\n    load: function(url, responseType, callback) {\n      if (fs) {\n        fs.readFile(url, { encoding: responseType == 'json' ? 'utf8' : null }, function (err, data) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          if (responseType == 'json') {\n            callback(null, JSON.parse(data));\n          } else\n          if (responseType == 'arraybuffer') {\n            if (data.buffer) {\n              callback(null, data.buffer);\n            } else {\n              var ab = new ArrayBuffer(data.length);\n              var view = new Uint8Array(ab);\n              for (var i = 0; i < data.length; ++i) {\n                  view[i] = data[i];\n              }\n              callback(null, ab);\n            }\n          } else {\n            callback(new Error('Unknown responseType'));\n          }\n        });\n        return;\n      }\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = responseType;\n\n      xhr.onload = function (e) {\n        if (xhr.response) {\n          callback && callback(null, xhr.response);\n        }\n      };\n\n      xhr.send(null);\n    },\n    extend: function() {\n      var result = {};\n      for (var i = 0; i < arguments.length; i++) {\n        for (var key in arguments[i]) {\n          result[key] = arguments[i][key];\n        }\n      }\n      return result;\n    }\n  };\n\n  return Az;\n}));\n\n;(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? (module.exports = module.exports || {}) && (module.exports.DAWG = factory(module.exports)) :\n  typeof define === 'function' && define.amd ? define('Az.DAWG', ['Az'], factory) :\n  (global.Az = global.Az || {}) && (global.Az.DAWG = factory(global.Az))\n}(this, function (Az) { 'use strict';\n  var ROOT = 0,\n      MISSING = -1,\n      PRECISION_MASK = 0xFFFFFFFF,\n      HAS_LEAF_BIT = 1 << 8,\n      EXTENSION_BIT = 1 << 9,\n      OFFSET_MAX = 1 << 21,\n      IS_LEAF_BIT = 1 << 31;\n\n  var CP1251 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16,\n    17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32,\n    33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48,\n    49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64,\n    65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80,\n    81: 81, 82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96,\n    97: 97, 98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106, 107: 107, 108: 108, 109: 109, 110: 110, 111: 111, 112: 112,\n    113: 113, 114: 114, 115: 115, 116: 116, 117: 117, 118: 118, 119: 119, 120: 120, 121: 121, 122: 122, 123: 123, 124: 124, 125: 125, 126: 126, 127: 127,\n    1027: 129, 8225: 135, 1046: 198, 8222: 132, 1047: 199, 1168: 165, 1048: 200, 1113: 154, 1049: 201, 1045: 197, 1050: 202, 1028: 170, 160: 160, 1040: 192,\n    1051: 203, 164: 164, 166: 166, 167: 167, 169: 169, 171: 171, 172: 172, 173: 173, 174: 174, 1053: 205, 176: 176, 177: 177, 1114: 156, 181: 181, 182: 182,\n    183: 183, 8221: 148, 187: 187, 1029: 189, 1056: 208, 1057: 209, 1058: 210, 8364: 136, 1112: 188, 1115: 158, 1059: 211, 1060: 212, 1030: 178, 1061: 213,\n    1062: 214, 1063: 215, 1116: 157, 1064: 216, 1065: 217, 1031: 175, 1066: 218, 1067: 219, 1068: 220, 1069: 221, 1070: 222, 1032: 163, 8226: 149, 1071: 223,\n    1072: 224, 8482: 153, 1073: 225, 8240: 137, 1118: 162, 1074: 226, 1110: 179, 8230: 133, 1075: 227, 1033: 138, 1076: 228, 1077: 229, 8211: 150, 1078: 230,\n    1119: 159, 1079: 231, 1042: 194, 1080: 232, 1034: 140, 1025: 168, 1081: 233, 1082: 234, 8212: 151, 1083: 235, 1169: 180, 1084: 236, 1052: 204, 1085: 237,\n    1035: 142, 1086: 238, 1087: 239, 1088: 240, 1089: 241, 1090: 242, 1036: 141, 1041: 193, 1091: 243, 1092: 244, 8224: 134, 1093: 245, 8470: 185, 1094: 246,\n    1054: 206, 1095: 247, 1096: 248, 8249: 139, 1097: 249, 1098: 250, 1044: 196, 1099: 251, 1111: 191, 1055: 207, 1100: 252, 1038: 161, 8220: 147, 1101: 253,\n    8250: 155, 1102: 254, 8216: 145, 1103: 255, 1043: 195, 1105: 184, 1039: 143, 1026: 128, 1106: 144, 8218: 130, 1107: 131, 8217: 146, 1108: 186, 1109: 190};\n\n  var UCS2 = {};\n  for (var k in CP1251) {\n    UCS2[CP1251[k]] = String.fromCharCode(k);\n    delete UCS2[0];\n    delete UCS2[1];\n  }\n\n  // Based on all common ЙЦУКЕН-keyboards (both Windows and Apple variations)\n  var COMMON_TYPOS = {\n    'й': 'ёцыф', 'ц': 'йфыву', 'у': 'цывак', 'к': 'увапе', 'е': 'капрн', 'н': 'епрог', 'г': 'нролш', 'ш': 'голдщ', 'щ': 'шлджз', 'з': 'щджэх-', 'х': 'зжэъ-', 'ъ': 'хэ-ё',\n    'ф': 'йцычяё', 'ы': 'йцувсчяф', 'в': 'цукамсчы', 'а': 'укепимсв', 'п': 'кенртима', 'р': 'енгоьтип', 'о': 'нгшлбьтр', 'л': 'гшщдюбьо', 'д': 'шщзжюбл', 'ж': 'щзхэюд', 'э': 'зхъжё',\n    'ё': 'йфяъэ', 'я': 'ёфыч', 'ч': 'яфывс', 'с': 'чывам', 'м': 'свапи', 'и': 'мапрт', 'т': 'ипроь', 'ь': 'тролб', 'б': 'ьолдю', 'ю': 'блдж',\n    '1': 'ёйц', '2': 'йцу', '3': 'цук', '4': 'уке', '5': 'кен', '6': 'енг', '7': 'нгш', '8': 'гшщ', '9': 'шщз', '0': 'щзх-', '-': 'зхъ', '=': '-хъ', '\\\\': 'ъэ', '.': 'южэ'\n  };\n\n  function offset(base) {\n    return ((base >> 10) << ((base & EXTENSION_BIT) >> 6)) & PRECISION_MASK;\n  }\n\n  function label(base) {\n    return base & (IS_LEAF_BIT | 0xFF) & PRECISION_MASK;\n  }\n\n  function hasLeaf(base) {\n    return (base & HAS_LEAF_BIT & PRECISION_MASK) != 0;\n  }\n\n  function value(base) {\n    return base & ~IS_LEAF_BIT & PRECISION_MASK;\n  }\n\n  var DAWG = function(units, guide, format) {\n    this.units = units;\n    this.guide = guide;\n    this.format = format;\n  }\n\n  DAWG.fromArrayBuffer = function(data, format) {\n    var dv = new DataView(data),\n        unitsLength = dv.getUint32(0, true),\n        guideLength = dv.getUint32(unitsLength * 4 + 4, true);\n    return new DAWG(\n      new Uint32Array(data, 4, unitsLength),\n      new Uint8Array(data, unitsLength * 4 + 8, guideLength * 2),\n      format);\n  }\n\n  DAWG.load = function(url, format, callback) {\n    Az.load(url, 'arraybuffer', function(err, data) {\n      callback(err, err ? null : DAWG.fromArrayBuffer(data, format));\n    });\n  }\n\n  DAWG.prototype.followByte = function(c, index) {\n    var o = offset(this.units[index]);\n    var nextIndex = (index ^ o ^ (c & 0xFF)) & PRECISION_MASK;\n\n    if (label(this.units[nextIndex]) != (c & 0xFF)) {\n      return MISSING;\n    }\n\n    return nextIndex;\n  }\n\n  DAWG.prototype.followString = function(str, index) {\n    index = index || ROOT;\n    for (var i = 0; i < str.length; i++) {\n      var code = str.charCodeAt(i);\n      if (!(code in CP1251)) {\n        return MISSING;\n      }\n      index = this.followByte(CP1251[code], index);\n      if (index == MISSING) {\n        return MISSING;\n      }\n    }\n    return index;\n  }\n\n  DAWG.prototype.hasValue = function(index) {\n    return hasLeaf(this.units[index]);\n  }\n\n  DAWG.prototype.value = function(index) {\n    var o = offset(this.units[index]);\n    var valueIndex = (index ^ o) & PRECISION_MASK;\n    return value(this.units[valueIndex]);\n  }\n\n  DAWG.prototype.find = function(str) {\n    var index = this.followString(str);\n    if (index == MISSING) {\n        return MISSING;\n    }\n    if (!this.hasValue(index)) {\n        return MISSING;\n    }\n    return this.value(index);\n  }\n\n  DAWG.prototype.iterateAll = function(index) {\n    var results = [];\n    var stack = [index];\n    var key = [];\n    var last = ROOT;\n    var label;\n\n    while (true) {\n      index = stack[stack.length - 1];\n\n      if (last != ROOT) {\n        label = this.guide[index << 1];\n        if (label) {\n          index = this.followByte(label, index);\n          if (index == MISSING) {\n            return results;\n          }\n          key.push(label);\n          stack.push(index);\n        } else {\n          do {\n            label = this.guide[(index << 1) + 1];\n            key.pop();\n            stack.pop();\n            if (!stack.length) {\n              return results;\n            }\n            index = stack[stack.length - 1];\n            if (label) {\n              index = this.followByte(label, index);\n              if (index == MISSING) {\n                return results;\n              }\n              key.push(label);\n              stack.push(index);\n            }\n          } while (!label);\n        }\n      }\n\n      while (!this.hasValue(index)) {\n        var label = this.guide[index << 1];\n        index = this.followByte(label, index);\n        if (index == MISSING) {\n          return results;\n        }\n        key.push(label);\n        stack.push(index);\n      }\n\n      // Only three formats supported\n      if (this.format == 'words') {\n        results.push([\n          ((key[0] ^ 1) << 6) + (key[1] >> 1),\n          ((key[2] ^ 1) << 6) + (key[3] >> 1)\n        ]);\n      } else\n      if (this.format == 'probs') {\n        results.push([\n          ((key[0] ^ 1) << 6) + (key[1] >> 1),\n          ((key[2] ^ 1) << 6) + (key[3] >> 1),\n          ((key[4] ^ 1) << 6) + (key[5] >> 1)\n        ]);\n      } else {\n        // Raw bytes\n        results.push(key.slice());\n      }\n      last = index;\n    }\n  }\n\n  // Features:\n  //  replaces (е -> ё) (DONE)\n  //  stutter (ннет -> нет, гоол -> гол, д-да -> да)\n  //  typos (count-limited):\n  //    swaps (солво -> слово)\n  //    extra letters (свлово -> слово)\n  //    missing letters (сово -> слово)\n  //    wrong letters (сково -> слово)\n  DAWG.prototype.findAll = function(str, replaces, mstutter, mtypos) {\n    mtypos = mtypos || 0;\n    mstutter = mstutter || 0;\n    var results = [],\n        prefixes = [['', 0, 0, 0, ROOT]],\n        prefix, index, len, code, cur, typos, stutter;\n\n    while (prefixes.length) {\n      prefix = prefixes.pop();\n      index = prefix[4], stutter = prefix[3], typos = prefix[2], len = prefix[1], prefix = prefix[0];\n\n      // Done\n      if (len == str.length) {\n        if (typos < mtypos && !stutter) {\n          // Allow missing letter(s) at the very end\n          var label = this.guide[index << 1]; // First child\n          do {\n            cur = this.followByte(label, index);\n            if ((cur != MISSING) && (label in UCS2)) {\n              prefixes.push([ prefix + UCS2[label], len, typos + 1, stutter, cur ]);\n            }\n            label = this.guide[(cur << 1) + 1]; // Next child\n          } while (cur != MISSING);\n        }\n\n        if (this.format == 'int') {\n          if (this.hasValue(index)) {\n            results.push([prefix, this.value(index)]);\n          }\n          continue;\n        }\n        // Find all payloads\n        if (this.format == 'words' || this.format == 'probs') {\n          index = this.followByte(1, index); // separator\n          if (index == MISSING) {\n            continue;\n          }\n        }\n        results.push([prefix, this.iterateAll(index), stutter, typos]);\n        continue;\n      }\n\n      // Follow a replacement path\n      if (replaces && str[len] in replaces) {\n        code = replaces[str[len]].charCodeAt(0);\n        if (code in CP1251) {\n          cur = this.followByte(CP1251[code], index);\n          if (cur != MISSING) {\n            prefixes.push([ prefix + replaces[str[len]], len + 1, typos, stutter, cur ]);\n          }\n        }\n      }\n\n      // Follow typos path (if not over limit)\n      if (typos < mtypos && !stutter) {\n        // Skip a letter entirely (extra letter)\n        prefixes.push([ prefix, len + 1, typos + 1, stutter, index ]);\n\n        // Add a letter (missing)\n        // TODO: iterate all childs?\n        var label = this.guide[index << 1]; // First child\n        do {\n          cur = this.followByte(label, index);\n          if ((cur != MISSING) && (label in UCS2)) {\n            prefixes.push([ prefix + UCS2[label], len, typos + 1, stutter, cur ]);\n          }\n          label = this.guide[(cur << 1) + 1]; // Next child\n        } while (cur != MISSING);\n\n        // Replace a letter\n        // Now it checks only most probable typos (located near to each other on keyboards)\n        var possible = COMMON_TYPOS[str[len]];\n        if (possible) {\n          for (var i = 0; i < possible.length; i++) {\n            code = possible.charCodeAt(i);\n            if (code in CP1251) {\n              cur = this.followByte(CP1251[code], index);\n              if (cur != MISSING) {\n                // for missing letter we need to iterate all childs, not only COMMON_TYPOS\n                // prefixes.push([ prefix + possible[i], len, typos + 1, stutter, cur ]);\n                prefixes.push([ prefix + possible[i], len + 1, typos + 1, stutter, cur ]);\n              }\n            }\n          }\n        }\n\n        // Swapped two letters\n        // TODO: support for replacements?\n        if (len < str.length - 1) {\n          code = str.charCodeAt(len + 1);\n          if (code in CP1251) {\n            cur = this.followByte(CP1251[code], index);\n            if (cur != MISSING) {\n              code = str.charCodeAt(len);\n              if (code in CP1251) {\n                cur = this.followByte(CP1251[code], cur);\n                if (cur != MISSING) {\n                  prefixes.push([ prefix + str[len + 1] + str[len], len + 2, typos + 1, stutter, cur ]);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Follow base path\n      code = str.charCodeAt(len);\n      if (code in CP1251) {\n        cur = this.followByte(CP1251[code], index);\n        if (cur != MISSING) {\n          prefixes.push([ prefix + str[len], len + 1, typos, stutter, cur ]);\n\n          while (stutter < mstutter && !typos && len < str.length - 1) {\n            // Follow a simple stutter path (merge two equal letters into one)\n            if (str[len] == str[len + 1]) {\n              prefixes.push([ prefix + str[len], len + 2, typos, stutter + 1, cur ]);\n              len++;\n            } else\n            // Follow a stutter with a dash (д-да)\n            if (len < str.length - 2 && str[len + 1] == '-' && str[len] == str[len + 2]) {\n              prefixes.push([ prefix + str[len], len + 3, typos, stutter + 1, cur ]);\n              len += 2;\n            } else {\n              break;\n            }\n            stutter++;\n          }\n        }\n      }\n    }\n    return results;\n  }\n\n  return DAWG;\n}));\n;(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? (module.exports = module.exports || {}) && (module.exports.Morph = factory(module.exports)) :\n  typeof define === 'function' && define.amd ? define('Az.Morph', ['Az', 'Az.DAWG'], factory) :\n  (global.Az = global.Az || {}) && (global.Az.Morph = factory(global.Az))\n}(this, function (Az) { 'use strict';\n  /** @namespace Az **/\n  var words,\n      probabilities,\n      predictionSuffixes = new Array(3),\n      prefixes = [ '', 'по', 'наи' ],\n      suffixes,\n      grammemes,\n      paradigms,\n      tags,\n      defaults = {\n        ignoreCase: false,\n        replacements: { 'е': 'ё' },\n        stutter: Infinity,\n        typos: 0,\n        parsers: [\n          // Словарные слова + инициалы\n          'Dictionary?', 'AbbrName?', 'AbbrPatronymic',\n          // Числа, пунктуация, латиница (по-хорошему, токенизатор не должен эту ерунду сюда пускать)\n          'IntNumber', 'RealNumber', 'Punctuation', 'RomanNumber?', 'Latin',\n          // Слова с дефисами\n          'HyphenParticle', 'HyphenAdverb', 'HyphenWords',\n          // Предсказатели по префиксам/суффиксам\n          'PrefixKnown', 'PrefixUnknown?', 'SuffixKnown?', 'Abbr'\n        ],\n        forceParse: false,\n        normalizeScore: true\n      },\n      initials = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЭЮЯ',\n      particles = ['-то', '-ка', '-таки', '-де', '-тко', '-тка', '-с', '-ста'],\n      knownPrefixes = [\n        'авиа', 'авто', 'аква', 'анти', 'анти-', 'антропо', 'архи', 'арт', 'арт-', 'астро', 'аудио', 'аэро',\n        'без', 'бес', 'био', 'вело', 'взаимо', 'вне', 'внутри', 'видео', 'вице-', 'вперед', 'впереди',\n        'гекто', 'гелио', 'гео', 'гетеро', 'гига', 'гигро', 'гипер', 'гипо', 'гомо',\n        'дву', 'двух', 'де', 'дез', 'дека', 'деци', 'дис', 'до', 'евро', 'за', 'зоо', 'интер', 'инфра',\n        'квази', 'квази-', 'кило', 'кино', 'контр', 'контр-', 'космо', 'космо-', 'крипто', 'лейб-', 'лже', 'лже-',\n        'макро', 'макси', 'макси-', 'мало', 'меж', 'медиа', 'медиа-', 'мега', 'мета', 'мета-', 'метео', 'метро', 'микро',\n        'милли', 'мини', 'мини-', 'моно', 'мото', 'много', 'мульти',\n        'нано', 'нарко', 'не', 'небез', 'недо', 'нейро', 'нео', 'низко', 'обер-', 'обще', 'одно', 'около', 'орто',\n        'палео', 'пан', 'пара', 'пента', 'пере', 'пиро', 'поли', 'полу', 'после', 'пост', 'пост-',\n        'порно', 'пра', 'пра-', 'пред', 'пресс-', 'противо', 'противо-', 'прото', 'псевдо', 'псевдо-',\n        'радио', 'разно', 'ре', 'ретро', 'ретро-', 'само', 'санти', 'сверх', 'сверх-', 'спец', 'суб', 'супер', 'супер-', 'супра',\n        'теле', 'тетра', 'топ-', 'транс', 'транс-', 'ультра', 'унтер-', 'штаб-',\n        'экзо', 'эко', 'эндо', 'эконом-', 'экс', 'экс-', 'экстра', 'экстра-', 'электро', 'энерго', 'этно'\n      ],\n      autoTypos = [4, 9],\n      UNKN,\n      __init = [],\n      initialized = false;\n\n  // Взято из https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n  function deepFreeze(obj) {\n    if (!('freeze' in Object)) {\n      return;\n    }\n\n    var propNames = Object.getOwnPropertyNames(obj);\n    propNames.forEach(function(name) {\n      var prop = obj[name];\n\n      if (typeof prop == 'object' && prop !== null)\n        deepFreeze(prop);\n    });\n\n    return Object.freeze(obj);\n  }\n\n  /**\n   * Тег. Содержит в себе информацию о конкретной форме слова, но при этом\n   * к конкретному слову не привязан. Всевозможные значения тегов переиспользуются\n   * для всех разборов слов.\n   *\n   * Все граммемы навешаны на тег как поля. Если какая-то граммема содержит в себе\n   * дочерние граммемы, то значением поля является именно название дочерней\n   * граммемы (например, tag.GNdr == 'masc'). В то же время для дочерних граммем\n   * значением является просто true (т.е. условие можно писать и просто как\n   * if (tag.masc) ...).\n   *\n   * @property {string[]} stat Полный список неизменяемых граммем.\n   * @property {string[]} flex Полный список изменяемых граммем.\n   * @property {Tag} ext Копия тега с русскими обозначениями (по версии OpenCorpora).\n   */\n  var Tag = function(str) {\n    var par, pair = str.split(' ');\n    this.stat = pair[0].split(',');\n    this.flex = pair[1] ? pair[1].split(',') : [];\n    for (var j = 0; j < 2; j++) {\n      var grams = this[['stat', 'flex'][j]];\n      for (var i = 0; i < grams.length; i++) {\n        var gram = grams[i];\n        this[gram] = true;\n        // loc2 -> loct -> CAse\n        while (grammemes[gram] && (par = grammemes[gram].parent)) {\n          this[par] = gram;\n          gram = par;\n        }\n      }\n    }\n    if ('POST' in this) {\n      this.POS = this.POST;\n    }\n  }\n\n  /**\n   * Возвращает текстовое представление тега.\n   *\n   * @returns {string} Список неизменяемых граммем через запятую, пробел,\n   *  и список изменяемых граммем через запятую.\n   */\n  Tag.prototype.toString = function() {\n    return (this.stat.join(',') + ' ' + this.flex.join(',')).trim();\n  }\n\n  /**\n   * Проверяет согласованность с конкретными значениями граммем либо со списком\n   * граммем из другого тега (или слова).\n   *\n   * @param {Tag|Parse} [tag] Тег или разбор слова, с которым следует\n   *  проверить согласованность.\n   * @param {Array|Object} grammemes Граммемы, по которым нужно проверить\n   *  согласованность.\n   *\n   *  Если указан тег (или разбор), то grammemes должен быть массивом тех\n   *  граммем, которые у обоих тегов должны совпадать. Например:\n   *  tag.matches(otherTag, ['POS', 'GNdr'])\n   *\n   *  Если тег не указан, а указан массив граммем, то проверяется просто их\n   *  наличие. Например, аналог выражения (tag.NOUN && tag.masc):\n   *  tag.matches([ 'NOUN', 'masc' ])\n   *\n   *  Если тег не указан, а указан объект, то ключи в нем — названия граммем,\n   *  значения — дочерние граммемы, массивы граммем, либо true/false:\n   *  tag.matches({ 'POS' : 'NOUN', 'GNdr': ['masc', 'neut'] })\n   * @returns {boolean} Является ли текущий тег согласованным с указанным.\n   */\n  // TODO: научиться понимать, что некоторые граммемы можно считать эквивалентными при сравнении двух тегов (вариации падежей и т.п.)\n  Tag.prototype.matches = function(tag, grammemes) {\n    if (!grammemes) {\n      if (Object.prototype.toString.call(tag) === '[object Array]') {\n        for (var i = 0; i < tag.length; i++) {\n          if (!this[tag[i]]) {\n            return false;\n          }\n        }\n        return true;\n      } else\n      // Match to map\n      for (var k in tag) {\n        if (Object.prototype.toString.call(tag[k]) === '[object Array]') {\n          if (!tag[k].indexOf(this[k])) {\n            return false;\n          }\n        } else {\n          if (tag[k] != this[k]) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    if (tag instanceof Parse) {\n      tag = tag.tag;\n    }\n\n    // Match to another tag\n    for (var i = 0; i < grammemes.length; i++) {\n      if (tag[grammemes[i]] != this[grammemes[i]]) {\n        // Special case: tag.CAse\n        return false;\n      }\n    }\n    return true;\n  }\n\n  Tag.prototype.isProductive = function() {\n    return !(this.NUMR || this.NPRO || this.PRED || this.PREP ||\n      this.CONJ || this.PRCL || this.INTJ || this.Apro ||\n      this.NUMB || this.ROMN || this.LATN || this.PNCT ||\n      this.UNKN);\n  }\n\n  Tag.prototype.isCapitalized = function() {\n    return this.Name || this.Surn || this.Patr || this.Geox || this.Init;\n  }\n\n  function makeTag(tagInt, tagExt) {\n    var tag = new Tag(tagInt);\n    tag.ext = new Tag(tagExt);\n    return deepFreeze(tag);\n  }\n\n  /**\n   * Производит морфологический анализ слова. Возвращает возможные варианты\n   * разбора по убыванию их правдоподобности.\n   *\n   * @playground\n   * var Az = require('az');\n   * Az.Morph.init(function() {\n   *   console.log(Az.Morph('стали'));\n   * });\n   * @param {string} word Слово, которое следует разобрать.\n   * @param {Object} [config] Опции разбора.\n   * @param {boolean} [config.ignoreCase=False] Следует ли игнорировать\n   *  регистр слов (в основном это означает возможность написания имен собственных и\n   *  инициалов с маленькой буквы).\n   * @param {Object} [config.replacements={ 'е': 'ё' }] Допустимые замены букв\n   *  при поиске слов в словаре. Ключи объекта — заменяемые буквы в разбираемом\n   *  слове, соответствующие им значения — буквы в словарных словах, которым\n   *  допустимо встречаться вместо заменяемых. По умолчанию буква «е» может\n   *  соответствовать букве «ё» в словарных словах.\n   * @param {number} [config.stutter=Infinity] «Заикание». Устраняет повторения букв\n   *  (как с дефисом - «не-е-ет», так и без - «нееет»).\n   *\n   *  Infinity не ограничивает максимальное число повторений (суммарно во всем слове).\n   *\n   *  0 или false чтобы отключить.\n   * @param {number|'auto'} [config.typos=0] Опечатки. Максимальное количество\n   * опечаток в слове.\n   *\n   *  Опечаткой считается:\n   *  - лишняя буква в слове\n   *  - пропущенная буква в слове (TODO: самый медленный тип опечаток, стоит сделать опциональным)\n   *  - не та буква в слове (если правильная буква стоит рядом на клавиатуре)\n   *  - переставленные местами соседние буквы\n   *\n   *  0 или false чтобы отключить.\n   *\n   *  'auto':\n   *  - 0, если слово короче 5 букв\n   *  - 1, если слово короче 10 букв (но только если не нашлось варианта разбора без опечаток)\n   *  - 2 в противном случае (но только если не нашлось варианта разбора без опечаток или с 1 опечаткой)\n   * @param {string[]} [config.parsers] Список применяемых парсеров (см. поля\n   *  объекта Az.Morph.Parsers) в порядке применения (т.е. стоящие в начале\n   *  имеют наивысший приоритет).\n   *\n   *  Вопросительный знак означает, что данный парсер не терминальный, то есть\n   *  варианты собираются до первого терминального парсера. Иными словами, если\n   *  мы дошли до какого-то парсера, значит все стоящие перед ним терминальные\n   *  парсеры либо не дали результата совсем, либо дали только с опечатками.\n   *\n   *  (парсер в терминологии pymorphy2 — анализатор)\n   * @param {boolean} [config.forceParse=False] Всегда возвращать хотя бы один вариант\n   *  разбора (как это делает pymorphy2), даже если совсем ничего не получилось.\n   * @returns {Parse[]} Варианты разбора.\n   * @memberof Az\n   */\n  var Morph = function(word, config) {\n    if (!initialized) {\n      throw new Error('Please call Az.Morph.init() before using this module.');\n    }\n\n    config = config ? Az.extend(defaults, config) : defaults;\n\n    var parses = [];\n    var matched = false;\n    for (var i = 0; i < config.parsers.length; i++) {\n      var name = config.parsers[i];\n      var terminal = name[name.length - 1] != '?';\n      name = terminal ? name : name.slice(0, -1);\n      if (name in Morph.Parsers) {\n        var vars = Morph.Parsers[name](word, config);\n        for (var j = 0; j < vars.length; j++) {\n          vars[j].parser = name;\n          if (!vars[j].stutterCnt && !vars[j].typosCnt) {\n            matched = true;\n          }\n        }\n\n        parses = parses.concat(vars);\n        if (matched && terminal) {\n          break;\n        }\n      } else {\n        console.warn('Parser \"' + name + '\" is not found. Skipping');\n      }\n    }\n\n    if (!parses.length && config.forceParse) {\n      parses.push(new Parse(word.toLocaleLowerCase(), UNKN));\n    }\n\n    var total = 0;\n    for (var i = 0; i < parses.length; i++) {\n      if (parses[i].parser == 'Dictionary') {\n        var res = probabilities.findAll(parses[i] + ':' + parses[i].tag);\n        if (res && res[0]) {\n          parses[i].score = (res[0][1] / 1000000) * getDictionaryScore(parses[i].stutterCnt, parses[i].typosCnt);\n          total += parses[i].score;\n        }\n      }\n    }\n\n    // Normalize Dictionary & non-Dictionary scores separately\n    if (config.normalizeScore) {\n      if (total > 0) {\n        for (var i = 0; i < parses.length; i++) {\n          if (parses[i].parser == 'Dictionary') {\n            parses[i].score /= total;\n          }\n        }\n      }\n\n      total = 0;\n      for (var i = 0; i < parses.length; i++) {\n        if (parses[i].parser != 'Dictionary') {\n          total += parses[i].score;\n        }\n      }\n      if (total > 0) {\n        for (var i = 0; i < parses.length; i++) {\n          if (parses[i].parser != 'Dictionary') {\n            parses[i].score /= total;\n          }\n        }\n      }\n    }\n\n    parses.sort(function(e1, e2) {\n      return e2.score - e1.score;\n    });\n\n    return parses;\n  }\n\n  // TODO: вынести парсеры в отдельный файл(ы)?\n\n  Morph.Parsers = {}\n\n  /**\n   * Один из возможных вариантов морфологического разбора.\n   *\n   * @property {string} word Слово в текущей форме (с исправленными ошибками,\n   *  если они были)\n   * @property {Tag} tag Тег, описывающий текущую форму слова.\n   * @property {number} score Число от 0 до 1, соответствующее «уверенности»\n   *  в данном разборе (чем оно выше, тем вероятнее данный вариант).\n   * @property {number} stutterCnt Число «заиканий», исправленных в слове.\n   * @property {number} typosCnt Число опечаток, исправленных в слове.\n   */\n  var Parse = function(word, tag, score, stutterCnt, typosCnt) {\n    this.word = word;\n    this.tag = tag;\n    this.stutterCnt = stutterCnt || 0;\n    this.typosCnt = typosCnt || 0;\n    this.score = score || 0;\n  }\n\n  /**\n   * Приводит слово к его начальной форме.\n   *\n   * @param {boolean} keepPOS Не менять часть речи при нормализации (например,\n   *  не делать из причастия инфинитив).\n   * @returns {Parse} Разбор, соответствующий начальной форме или False,\n   *  если произвести нормализацию не удалось.\n   */\n  // TODO: некоторые смены частей речи, возможно, стоит делать в любом случае (т.к., например, компаративы, краткие формы причастий и прилагательных разделены, инфинитив отделен от глагола)\n  Parse.prototype.normalize = function(keepPOS) {\n    return this.inflect(keepPOS ? { POS: this.tag.POS } : 0);\n  }\n\n  /**\n   * Приводит слово к указанной форме.\n   *\n   * @param {Tag|Parse} [tag] Тег или другой разбор слова, с которым следует\n   *  согласовать данный.\n   * @param {Array|Object} grammemes Граммемы, по которым нужно согласовать слово.\n   * @returns {Parse|False} Разбор, соответствующий указанной форме или False,\n   *  если произвести согласование не удалось.\n   * @see Tag.matches\n   */\n  Parse.prototype.inflect = function(tag, grammemes) {\n    return this;\n  }\n\n  /**\n   * Приводит слово к форме, согласующейся с указанным числом.\n   * Вместо конкретного числа можно указать категорию (согласно http://www.unicode.org/cldr/charts/29/supplemental/language_plural_rules.html).\n   *\n   * @param {number|string} number Число, с которым нужно согласовать данное слово или категория, описывающая правило построения множественного числа.\n   * @returns {Parse|False} Разбор, соответствующий указанному числу или False,\n   *  если произвести согласование не удалось.\n   */\n  Parse.prototype.pluralize = function(number) {\n    if (!this.tag.NOUN && !this.tag.ADJF && !this.tag.PRTF) {\n      return this;\n    }\n\n    if (typeof number == 'number') {\n      number = number % 100;\n      if ((number % 10 == 0) || (number % 10 > 4) || (number > 4 && number < 21)) {\n        number = 'many';\n      } else\n      if (number % 10 == 1) {\n        number = 'one';\n      } else {\n        number = 'few';\n      }\n    }\n\n    if (this.tag.NOUN && !this.tag.nomn && !this.tag.accs) {\n      return this.inflect([number == 'one' ? 'sing' : 'plur', this.tag.CAse]);\n    } else\n    if (number == 'one') {\n      return this.inflect(['sing', this.tag.nomn ? 'nomn' : 'accs'])\n    } else\n    if (this.tag.NOUN && (number == 'few')) {\n      return this.inflect(['sing', 'gent']);\n    } else\n    if ((this.tag.ADJF || this.tag.PRTF) && this.tag.femn && (number == 'few')) {\n      return this.inflect(['plur', 'nomn']);\n    } else {\n      return this.inflect(['plur', 'gent']);\n    }\n  }\n\n  /**\n   * Проверяет, согласуется ли текущая форма слова с указанной.\n   *\n   * @param {Tag|Parse} [tag] Тег или другой разбор слова, с которым следует\n   *  проверить согласованность.\n   * @param {Array|Object} grammemes Граммемы, по которым нужно проверить\n   *  согласованность.\n   * @returns {boolean} Является ли текущая форма слова согласованной с указанной.\n   * @see Tag.matches\n   */\n  Parse.prototype.matches = function(tag, grammemes) {\n    return this.tag.matches(tag, grammemes);\n  }\n\n  /**\n   * Возвращает текущую форму слова.\n   *\n   * @returns {String} Текущая форма слова.\n   */\n  Parse.prototype.toString = function() {\n    return this.word;\n  }\n\n  // Выводит информацию о слове в консоль.\n  Parse.prototype.log = function() {\n    console.group(this.toString());\n    console.log('Stutter?', this.stutterCnt, 'Typos?', this.typosCnt);\n    console.log(this.tag.ext.toString());\n    console.groupEnd();\n  }\n\n  function lookup(dawg, word, config) {\n    var entries;\n    if (config.typos == 'auto') {\n      entries = dawg.findAll(word, config.replacements, config.stutter, 0);\n      for (var i = 0; i < autoTypos.length && !entries.length && word.length > autoTypos[i]; i++) {\n        entries = dawg.findAll(word, config.replacements, config.stutter, i + 1);\n      }\n    } else {\n      entries = dawg.findAll(word, config.replacements, config.stutter, config.typos);\n    }\n    return entries;\n  }\n\n  function getDictionaryScore(stutterCnt, typosCnt) {\n    // = 1.0 if no stutter/typos\n    // = 0.3 if any number of stutter or 1 typo\n    // = 0.09 if 2 typos\n    // = 0.027 if 3 typos\n    return Math.pow(0.3, Math.min(stutterCnt, 1) + typosCnt);\n  }\n\n  var DictionaryParse = function(word, paradigmIdx, formIdx, stutterCnt, typosCnt, prefix, suffix) {\n    this.word = word;\n    this.paradigmIdx = paradigmIdx;\n    this.paradigm = paradigms[paradigmIdx];\n    this.formIdx = formIdx;\n    this.formCnt = this.paradigm.length / 3;\n    this.tag = tags[this.paradigm[this.formCnt + formIdx]];\n    this.stutterCnt = stutterCnt || 0;\n    this.typosCnt = typosCnt || 0;\n    this.score = getDictionaryScore(this.stutterCnt, this.typosCnt);\n    this.prefix = prefix || '';\n    this.suffix = suffix || '';\n  }\n\n  DictionaryParse.prototype = Object.create(Parse.prototype);\n  DictionaryParse.prototype.constructor = DictionaryParse;\n\n  // Возвращает основу слова\n  DictionaryParse.prototype.base = function() {\n    if (this._base) {\n      return this._base;\n    }\n    return (this._base = this.word.substring(\n      prefixes[this.paradigm[(this.formCnt << 1) + this.formIdx]].length,\n      this.word.length - suffixes[this.paradigm[this.formIdx]].length)\n    );\n  }\n\n  // Склоняет/спрягает слово так, чтобы оно соответствовало граммемам другого слова, тега или просто конкретным граммемам (подробнее см. Tag.prototype.matches).\n  // Всегда выбирается первый подходящий вариант.\n  DictionaryParse.prototype.inflect = function(tag, grammemes) {\n    if (!grammemes && typeof tag === 'number') {\n      // Inflect to specific formIdx\n      return new DictionaryParse(\n          prefixes[this.paradigm[(this.formCnt << 1) + tag]] +\n          this.base() +\n          suffixes[this.paradigm[tag]],\n        this.paradigmIdx,\n        tag, 0, 0, this.prefix, this.suffix\n      );\n    }\n\n    for (var formIdx = 0; formIdx < this.formCnt; formIdx++) {\n      if (tags[this.paradigm[this.formCnt + formIdx]].matches(tag, grammemes)) {\n        return new DictionaryParse(\n            prefixes[this.paradigm[(this.formCnt << 1) + formIdx]] +\n            this.base() +\n            suffixes[this.paradigm[formIdx]],\n          this.paradigmIdx,\n          formIdx, 0, 0, this.prefix, this.suffix\n        );\n      }\n    }\n\n    return false;\n  }\n\n  DictionaryParse.prototype.log = function() {\n    console.group(this.toString());\n    console.log('Stutter?', this.stutterCnt, 'Typos?', this.typosCnt);\n    console.log(prefixes[this.paradigm[(this.formCnt << 1) + this.formIdx]] + '|' + this.base() + '|' + suffixes[this.paradigm[this.formIdx]]);\n    console.log(this.tag.ext.toString());\n    var norm = this.normalize();\n    console.log('=> ', norm + ' (' + norm.tag.ext.toString() + ')');\n    norm = this.normalize(true);\n    console.log('=> ', norm + ' (' + norm.tag.ext.toString() + ')');\n    console.groupCollapsed('Все формы: ' + this.formCnt);\n    for (var formIdx = 0; formIdx < this.formCnt; formIdx++) {\n      var form = this.inflect(formIdx);\n      console.log(form + ' (' + form.tag.ext.toString() + ')');\n    }\n    console.groupEnd();\n    console.groupEnd();\n  }\n\n  DictionaryParse.prototype.toString = function() {\n    if (this.prefix) {\n      var pref = prefixes[this.paradigm[(this.formCnt << 1) + this.formIdx]];\n      return pref + this.prefix + this.word.substr(pref.length) + this.suffix;\n    } else {\n      return this.word + this.suffix;\n    }\n  }\n\n  var CombinedParse = function(left, right) {\n    this.left = left;\n    this.right = right;\n    this.tag = right.tag;\n    this.score = left.score * right.score * 0.8;\n    this.stutterCnt = left.stutterCnt + right.stutterCnt;\n    this.typosCnt = left.typosCnt + right.typosCnt;\n    if ('formCnt' in right) {\n      this.formCnt = right.formCnt;\n    }\n  }\n\n  CombinedParse.prototype = Object.create(Parse.prototype);\n  CombinedParse.prototype.constructor = CombinedParse;\n\n  CombinedParse.prototype.inflect = function(tag, grammemes) {\n    var left, right;\n\n    var right = this.right.inflect(tag, grammemes);\n    if (!grammemes && typeof tag === 'number') {\n      left = this.left.inflect(right.tag, ['POST', 'NMbr', 'CAse', 'PErs', 'TEns']);\n    } else {\n      left = this.left.inflect(tag, grammemes);\n    }\n    if (left && right) {\n      return new CombinedParse(left, right);\n    } else {\n      return false;\n    }\n  }\n\n  CombinedParse.prototype.toString = function() {\n    return this.left.word + '-' + this.right.word;\n  }\n\n  __init.push(function() {\n    Morph.Parsers.Dictionary = function(word, config) {\n      var isCapitalized =\n        !config.ignoreCase && word.length &&\n        (word[0].toLocaleLowerCase() != word[0]) &&\n        (word.substr(1).toLocaleUpperCase() != word.substr(1));\n      word = word.toLocaleLowerCase();\n\n      var opts = lookup(words, word, config);\n\n      var vars = [];\n      for (var i = 0; i < opts.length; i++) {\n        for (var j = 0; j < opts[i][1].length; j++) {\n          var w = new DictionaryParse(\n            opts[i][0],\n            opts[i][1][j][0],\n            opts[i][1][j][1],\n            opts[i][2],\n            opts[i][3]);\n          if (config.ignoreCase || !w.tag.isCapitalized() || isCapitalized) {\n            vars.push(w);\n          }\n        }\n      }\n      return vars;\n    }\n\n    var abbrTags = [];\n    for (var i = 0; i <= 2; i++) {\n      for (var j = 0; j <= 5; j++) {\n        for (var k = 0; k <= 1; k++) {\n          abbrTags.push(makeTag(\n            'NOUN,inan,' + ['masc', 'femn', 'neut'][i] + ',Fixd,Abbr ' + ['sing', 'plur'][k] + ',' + ['nomn', 'gent', 'datv', 'accs', 'ablt', 'loct'][j],\n            'СУЩ,неод,' + ['мр', 'жр', 'ср'][i] + ',0,аббр ' + ['ед', 'мн'][k] + ',' + ['им', 'рд', 'дт', 'вн', 'тв', 'пр'][j]\n          ));\n        }\n      }\n    }\n\n    // Произвольные аббревиатуры (несклоняемые)\n    // ВК, ЖК, ССМО, ОАО, ЛенСпецСМУ\n    Morph.Parsers.Abbr = function(word, config) {\n      // Однобуквенные считаются инициалами и для них заведены отдельные парсеры\n      if (word.length < 2) {\n        return [];\n      }\n      // Дефисов в аббревиатуре быть не должно\n      if (word.indexOf('-') > -1) {\n        return [];\n      }\n      // Первая буква должна быть заглавной: сокращения с маленькой буквы (типа iOS) мало распространены\n      // Последняя буква должна быть заглавной: иначе сокращение, вероятно, склоняется\n      if ((initials.indexOf(word[0]) > -1) && (initials.indexOf(word[word.length - 1]) > -1)) {\n        var caps = 0;\n        for (var i = 0; i < word.length; i++) {\n          if (initials.indexOf(word[i]) > -1) {\n            caps++;\n          }\n        }\n        if (caps <= 5) {\n          var vars = [];\n          for (var i = 0; i < abbrTags.length; i++) {\n            var w = new Parse(word, abbrTags[i], 0.5);\n            vars.push(w);\n          }\n          return vars;\n        }\n      }\n      // При игнорировании регистра разбираем только короткие аббревиатуры\n      // (и требуем, чтобы каждая буква была «инициалом», т.е. без мягких/твердых знаков)\n      if (!config.ignoreCase || (word.length > 5)) {\n        return [];\n      }\n      word = word.toLocaleUpperCase();\n      for (var i = 0; i < word.length; i++) {\n        if (initials.indexOf(word[i]) == -1) {\n          return [];\n        }\n      }\n      var vars = [];\n      for (var i = 0; i < abbrTags.length; i++) {\n        var w = new Parse(word, abbrTags[i], 0.2);\n        vars.push(w);\n      }\n      return vars;\n    }\n\n    var InitialsParser = function(isPatronymic, score) {\n      var initialsTags = [];\n      for (var i = 0; i <= 1; i++) {\n        for (var j = 0; j <= 5; j++) {\n          initialsTags.push(makeTag(\n            'NOUN,anim,' + ['masc', 'femn'][i] + ',Sgtm,Name,Fixd,Abbr,Init sing,' + ['nomn', 'gent', 'datv', 'accs', 'ablt', 'loct'][j],\n            'СУЩ,од,' + ['мр', 'жр'][i] + ',sg,имя,0,аббр,иниц ед,' + ['им', 'рд', 'дт', 'вн', 'тв', 'пр'][j]\n          ));\n        }\n      }\n      return function(word, config) {\n        if (word.length != 1) {\n          return [];\n        }\n        if (config.ignoreCase) {\n          word = word.toLocaleUpperCase();\n        }\n        if (initials.indexOf(word) == -1) {\n          return [];\n        }\n        var vars = [];\n        for (var i = 0; i < initialsTags.length; i++) {\n          var w = new Parse(word, initialsTags[i], score);\n          vars.push(w);\n        }\n        return vars;\n      }\n    }\n\n    Morph.Parsers.AbbrName = InitialsParser(false, 0.1);\n    Morph.Parsers.AbbrPatronymic = InitialsParser(true, 0.1);\n\n    var RegexpParser = function(regexp, tag, score) {\n      return function(word, config) {\n        if (config.ignoreCase) {\n          word = word.toLocaleUpperCase();\n        }\n        if (word.length && word.match(regexp)) {\n          return [new Parse(word, tag)];\n        } else {\n          return [];\n        }\n      }\n    }\n\n    grammemes['NUMB'] = grammemes['ЧИСЛО'] =\n    grammemes['ROMN'] = grammemes['РИМ'] =\n    grammemes['LATN'] = grammemes['ЛАТ'] =\n    grammemes['PNCT'] = grammemes['ЗПР'] =\n    grammemes['UNKN'] = grammemes['НЕИЗВ'] =\n     { parent: 'POST' };\n\n    Morph.Parsers.IntNumber = RegexpParser(\n      /^[−-]?[0-9]+$/,\n      makeTag('NUMB,intg', 'ЧИСЛО,цел'), 0.9);\n\n    Morph.Parsers.RealNumber = RegexpParser(\n      /^[−-]?([0-9]*[.,][0-9]+)$/,\n      makeTag('NUMB,real', 'ЧИСЛО,вещ'), 0.9);\n\n    Morph.Parsers.Punctuation = RegexpParser(\n      /^[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,\\-.\\/:;<=>?@\\[\\]^_`{|}~]+$/,\n      makeTag('PNCT', 'ЗПР'), 0.9);\n\n    Morph.Parsers.RomanNumber = RegexpParser(\n      /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/,\n      makeTag('ROMN', 'РИМ'), 0.9);\n\n    Morph.Parsers.Latin = RegexpParser(\n      /[A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00f6\\u00f8-\\u024f]$/,\n      makeTag('LATN', 'ЛАТ'), 0.9);\n\n    // слово + частица\n    // смотри-ка\n    Morph.Parsers.HyphenParticle = function(word, config) {\n      word = word.toLocaleLowerCase();\n\n      var vars = [];\n      for (var k = 0; k < particles.length; k++) {\n        if (word.substr(word.length - particles[k].length) == particles[k]) {\n          var base = word.slice(0, -particles[k].length);\n          var opts = lookup(words, base, config);\n\n          //console.log(opts);\n          for (var i = 0; i < opts.length; i++) {\n            for (var j = 0; j < opts[i][1].length; j++) {\n              var w = new DictionaryParse(\n                opts[i][0],\n                opts[i][1][j][0],\n                opts[i][1][j][1],\n                opts[i][2],\n                opts[i][3],\n                '', particles[k]);\n              w.score *= 0.9;\n              vars.push(w);\n            }\n          }\n        }\n      }\n\n      return vars;\n    }\n\n    var ADVB = makeTag('ADVB', 'Н');\n\n    // 'по-' + прилагательное в дательном падеже\n    // по-западному\n    Morph.Parsers.HyphenAdverb = function(word, config) {\n      word = word.toLocaleLowerCase();\n\n      if ((word.length < 5) || (word.substr(0, 3) != 'по-')) {\n        return [];\n      }\n\n      var opts = lookup(words, word.substr(3), config);\n\n      var parses = [];\n      var used = {};\n\n      for (var i = 0; i < opts.length; i++) {\n        if (!used[opts[i][0]]) {\n          for (var j = 0; j < opts[i][1].length; j++) {\n            var parse = new DictionaryParse(opts[i][0], opts[i][1][j][0], opts[i][1][j][1], opts[i][2], opts[i][3]);\n            if (parse.matches(['ADJF', 'sing', 'datv'])) {\n              used[opts[i][0]] = true;\n\n              parse = new Parse('по-' + opts[i][0], ADVB, parse.score * 0.9, opts[i][2], opts[i][3]);\n              parses.push(parse);\n              break;\n            }\n          }\n        }\n      }\n      return parses;\n    }\n\n    // слово + '-' + слово\n    // интернет-магазин\n    // компания-производитель\n    Morph.Parsers.HyphenWords = function(word, config) {\n      word = word.toLocaleLowerCase();\n      for (var i = 0; i < knownPrefixes.length; i++) {\n        if (knownPrefixes[i][knownPrefixes[i].length - 1] == '-' &&\n            word.substr(0, knownPrefixes[i].length) == knownPrefixes[i]) {\n          return [];\n        }\n      }\n      var parses = [];\n      var parts = word.split('-');\n      if (parts.length != 2 || !parts[0].length || !parts[1].length) {\n        if (parts.length > 2) {\n          var end = parts[parts.length - 1];\n          var right = Morph.Parsers.Dictionary(end, config);\n          for (var j = 0; j < right.length; j++) {\n            if (right[j] instanceof DictionaryParse) {\n              right[j].score *= 0.2;\n              right[j].prefix = word.substr(0, word.length - end.length - 1) + '-';\n              parses.push(right[j]);\n            }\n          }\n        }\n        return parses;\n      }\n      var left = Morph.Parsers.Dictionary(parts[0], config);\n      var right = Morph.Parsers.Dictionary(parts[1], config);\n\n\n      // Variable\n      for (var i = 0; i < left.length; i++) {\n        if (left[i].tag.Abbr) {\n          continue;\n        }\n        for (var j = 0; j < right.length; j++) {\n          if (!left[i].matches(right[j], ['POST', 'NMbr', 'CAse', 'PErs', 'TEns'])) {\n            continue;\n          }\n          if (left[i].stutterCnt + right[j].stutterCnt > config.stutter ||\n              left[i].typosCnt + right[j].typosCnt > config.typos) {\n            continue;\n          }\n          parses.push(new CombinedParse(left[i], right[j]));\n        }\n      }\n      // Fixed\n      for (var j = 0; j < right.length; j++) {\n        if (right[j] instanceof DictionaryParse) {\n          right[j].score *= 0.3;\n          right[j].prefix = parts[0] + '-';\n          parses.push(right[j]);\n        }\n      }\n\n      return parses;\n    }\n\n\n    Morph.Parsers.PrefixKnown = function(word, config) {\n      var isCapitalized =\n        !config.ignoreCase && word.length &&\n        (word[0].toLocaleLowerCase() != word[0]) &&\n        (word.substr(1).toLocaleUpperCase() != word.substr(1));\n      word = word.toLocaleLowerCase();\n      var parses = [];\n      for (var i = 0; i < knownPrefixes.length; i++) {\n        if (word.length - knownPrefixes[i].length < 3) {\n          continue;\n        }\n\n        if (word.substr(0, knownPrefixes[i].length) == knownPrefixes[i]) {\n          var end = word.substr(knownPrefixes[i].length);\n          var right = Morph.Parsers.Dictionary(end, config);\n          for (var j = 0; j < right.length; j++) {\n            if (!right[j].tag.isProductive()) {\n              continue;\n            }\n            if (!config.ignoreCase && right[j].tag.isCapitalized() && !isCapitalized) {\n              continue;\n            }\n            right[j].score *= 0.7;\n            right[j].prefix = knownPrefixes[i];\n            parses.push(right[j]);\n          }\n        }\n      }\n      return parses;\n    }\n\n    Morph.Parsers.PrefixUnknown = function(word, config) {\n      var isCapitalized =\n        !config.ignoreCase && word.length &&\n        (word[0].toLocaleLowerCase() != word[0]) &&\n        (word.substr(1).toLocaleUpperCase() != word.substr(1));\n      word = word.toLocaleLowerCase();\n      var parses = [];\n      for (var len = 1; len <= 5; len++) {\n        if (word.length - len < 3) {\n          break;\n        }\n        var end = word.substr(len);\n        var right = Morph.Parsers.Dictionary(end, config);\n        for (var j = 0; j < right.length; j++) {\n          if (!right[j].tag.isProductive()) {\n            continue;\n          }\n          if (!config.ignoreCase && right[j].tag.isCapitalized() && !isCapitalized) {\n            continue;\n          }\n          right[j].score *= 0.3;\n          right[j].prefix = word.substr(0, len);\n          parses.push(right[j]);\n        }\n      }\n      return parses;\n    }\n\n    // Отличие от предсказателя по суффиксам в pymorphy2: найдя подходящий суффикс, проверяем ещё и тот, что на символ короче\n    Morph.Parsers.SuffixKnown = function(word, config) {\n      if (word.length < 4) {\n        return [];\n      }\n      var isCapitalized =\n        !config.ignoreCase && word.length &&\n        (word[0].toLocaleLowerCase() != word[0]) &&\n        (word.substr(1).toLocaleUpperCase() != word.substr(1));\n      word = word.toLocaleLowerCase();\n      var parses = [];\n      var minlen = 1;\n      var coeffs = [0, 0.2, 0.3, 0.4, 0.5, 0.6];\n      var used = {};\n      for (var i = 0; i < prefixes.length; i++) {\n        if (prefixes[i].length && (word.substr(0, prefixes[i].length) != prefixes[i])) {\n          continue;\n        }\n        var base = word.substr(prefixes[i].length);\n        for (var len = 5; len >= minlen; len--) {\n          if (len >= base.length) {\n            continue;\n          }\n          var left = base.substr(0, base.length - len);\n          var right = base.substr(base.length - len);\n          var entries = predictionSuffixes[i].findAll(right, config.replacements, 0, 0);\n          if (!entries) {\n            continue;\n          }\n\n          var p = [];\n          var max = 1;\n          for (var j = 0; j < entries.length; j++) {\n            var suffix = entries[j][0];\n            var stats = entries[j][1];\n\n            for (var k = 0; k < stats.length; k++) {\n              var parse = new DictionaryParse(\n                prefixes[i] + left + suffix,\n                stats[k][1],\n                stats[k][2]);\n              // Why there is even non-productive forms in suffix DAWGs?\n              if (!parse.tag.isProductive()) {\n                continue;\n              }\n              if (!config.ignoreCase && parse.tag.isCapitalized() && !isCapitalized) {\n                continue;\n              }\n              var key = parse.toString() + ':' + stats[k][1] + ':' + stats[k][2];\n              if (key in used) {\n                continue;\n              }\n              max = Math.max(max, stats[k][0]);\n              parse.score = stats[k][0] * coeffs[len];\n              p.push(parse);\n              used[key] = true;\n            }\n          }\n          if (p.length > 0) {\n            for (var j = 0; j < p.length; j++) {\n              p[j].score /= max;\n            }\n            parses = parses.concat(p);\n            // Check also suffixes 1 letter shorter\n            minlen = Math.max(len - 1, 1);\n          }\n        }\n      }\n      return parses;\n    }\n\n    UNKN = makeTag('UNKN', 'НЕИЗВ');\n  });\n\n  /**\n   * Задает опции морфологического анализатора по умолчанию.\n   *\n   * @param {Object} config Опции анализатора.\n   * @see Morph\n   */\n  Morph.setDefaults = function(config) {\n    defaults = config;\n  }\n\n  /**\n   * Инициализирует анализатор, загружая необходимые для работы словари из\n   * указанной директории. Эту функцию необходимо вызвать (и дождаться\n   * срабатывания коллбэка) до любых действий с модулем.\n   *\n   * @param {string} [path] Директория, содержащая файлы 'words.dawg',\n   * 'grammemes.json' и т.д. По умолчанию директория 'dicts' в данном модуле.\n   * @param {Function} callback Коллбэк, вызываемый после завершения загрузки\n   *  всех словарей.\n   */\n  Morph.init = function(path, callback) {\n    var loading = 0;\n    var tagsInt, tagsExt;\n    function loaded() {\n      if (!--loading) {\n        tags = Array(tagsInt.length);\n        for (var i = 0; i < tagsInt.length; i++) {\n          tags[i] = new Tag(tagsInt[i]);\n          tags[i].ext = new Tag(tagsExt[i]);\n        }\n        tags = deepFreeze(tags);\n        for (var i = 0; i < __init.length; i++) {\n          __init[i]();\n        }\n        initialized = true;\n        callback && callback(null, Morph);\n      }\n    }\n\n    if (!callback && typeof path == 'function') {\n      callback = path;\n      if (typeof __dirname == 'string') {\n        path = __dirname + '/../dicts';\n      } else {\n        path = 'dicts';\n      }\n    }\n\n    loading++;\n    Az.DAWG.load(path + '/words.dawg', 'words', function(err, dawg) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      words = dawg;\n      loaded();\n    });\n\n    for (var prefix = 0; prefix < 3; prefix++) {\n      (function(prefix) {\n        loading++;\n        Az.DAWG.load(path + '/prediction-suffixes-' + prefix + '.dawg', 'probs', function(err, dawg) {\n          if (err) {\n            callback(err);\n            return;\n          }\n          predictionSuffixes[prefix] = dawg;\n          loaded();\n        });\n      })(prefix);\n    }\n\n    loading++;\n    Az.DAWG.load(path + '/p_t_given_w.intdawg', 'int', function(err, dawg) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      probabilities = dawg;\n      loaded();\n    });\n\n    loading++;\n    Az.load(path + '/grammemes.json', 'json', function(err, json) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      grammemes = {};\n      for (var i = 0; i < json.length; i++) {\n        grammemes[json[i][0]] = grammemes[json[i][2]] = {\n          parent: json[i][1],\n          internal: json[i][0],\n          external: json[i][2],\n          externalFull: json[i][3]\n        }\n      }\n      loaded();\n    });\n\n    loading++;\n    Az.load(path + '/gramtab-opencorpora-int.json', 'json', function(err, json) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      tagsInt = json;\n      loaded();\n    });\n\n    loading++;\n    Az.load(path + '/gramtab-opencorpora-ext.json', 'json', function(err, json) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      tagsExt = json;\n      loaded();\n    });\n\n    loading++;\n    Az.load(path + '/suffixes.json', 'json', function(err, json) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      suffixes = json;\n      loaded();\n    });\n\n    loading++;\n    Az.load(path + '/paradigms.array', 'arraybuffer', function(err, data) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      \n      var list = new Uint16Array(data),\n          count = list[0],\n          pos = 1;\n\n      paradigms = [];\n      for (var i = 0; i < count; i++) {\n        var size = list[pos++];\n        paradigms.push(list.subarray(pos, pos + size));\n        pos += size;\n      }\n      loaded();\n    });\n  }\n\n  return Morph;\n}));\n\n;(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? (module.exports = module.exports || {}) && (module.exports.Syntax = factory(module.exports)) :\r\n  typeof define === 'function' && define.amd ? define('Az.Syntax', ['Az'], factory) :\r\n  (global.Az = global.Az || {}) && (global.Az.Syntax = factory(global.Az))\r\n}(this, function (Az) { 'use strict';\r\n  // TBD: Syntax analyzer\r\n  var Syntax = function() {\r\n\r\n  }\r\n\r\n  return Syntax;\r\n}));\n;(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? (module.exports = module.exports || {}) && (module.exports.Tokens = factory()) :\n  typeof define === 'function' && define.amd ? define('Az.Tokens', ['Az'], factory) :\n  (global.Az = global.Az || {}) && (global.Az.Tokens = factory())\n}(this, function () { 'use strict';\n  /** @namespace Az **/\n  var TLDs = 'ac|ad|ae|aero|af|ag|ai|al|am|ao|aq|ar|arpa|as|asia|at|au|aw|ax|az|ba|bb|be|bf|bg|bh|bi|biz|bj|bm|bo|br|bs|bt|bv|bw|by|bz|ca|cat|cc|cd|cf|cg|ch|ci|cl|cm|cn|co|com|coop|cr|cu|cv|cw|cx|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg|es|et|eu|fi|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gov|gp|gq|gr|gs|gt|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|info|int|io|iq|ir|is|it|je|jo|jobs|jp|kg|ki|km|kn|kp|kr|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mil|mk|ml|mn|mo|mobi|mp|mq|mr|ms|mt|mu|museum|mv|mw|mx|my|na|name|nc|ne|net|nf|ng|nl|no|nr|nu|nz|om|org|pa|pe|pf|ph|pk|pl|pm|pn|post|pr|pro|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm|tn|to|tr|travel|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|yt|امارات|հայ|বাংলা|бел|中国|中國|الجزائر|مصر|ею|გე|ελ|香港|भारत|بھارت|భారత్|ભારત|ਭਾਰਤ|ভারত|இந்தியா|ایران|ايران|عراق|الاردن|한국|қаз|ලංකා|இலங்கை|المغرب|мкд|мон|澳門|澳门|مليسيا|عمان|پاکستان|پاكستان|فلسطين|срб|рф|قطر|السعودية|السعودیة|السعودیۃ|السعوديه|سودان|新加坡|சிங்கப்பூர்|سورية|سوريا|ไทย|تونس|台灣|台湾|臺灣|укр|اليمن|xxx|zm|aaa|aarp|abarth|abb|abbott|abbvie|abc|able|abogado|abudhabi|academy|accenture|accountant|accountants|aco|active|actor|adac|ads|adult|aeg|aetna|afamilycompany|afl|africa|africamagic|agakhan|agency|aig|aigo|airbus|airforce|airtel|akdn|alfaromeo|alibaba|alipay|allfinanz|allstate|ally|alsace|alstom|americanexpress|americanfamily|amex|amfam|amica|amsterdam|analytics|android|anquan|anz|aol|apartments|app|apple|aquarelle|arab|aramco|archi|army|art|arte|asda|associates|athleta|attorney|auction|audi|audible|audio|auspost|author|auto|autos|avianca|aws|axa|azure|baby|baidu|banamex|bananarepublic|band|bank|bar|barcelona|barclaycard|barclays|barefoot|bargains|baseball|basketball|bauhaus|bayern|bbc|bbt|bbva|bcg|bcn|beats|beauty|beer|bentley|berlin|best|bestbuy|bet|bharti|bible|bid|bike|bing|bingo|bio|black|blackfriday|blanco|blockbuster|blog|bloomberg|blue|bms|bmw|bnl|bnpparibas|boats|boehringer|bofa|bom|bond|boo|book|booking|boots|bosch|bostik|boston|bot|boutique|box|bradesco|bridgestone|broadway|broker|brother|brussels|budapest|bugatti|build|builders|business|buy|buzz|bzh|cab|cafe|cal|call|calvinklein|camera|camp|cancerresearch|canon|capetown|capital|capitalone|car|caravan|cards|care|career|careers|cars|cartier|casa|case|caseih|cash|casino|catering|catholic|cba|cbn|cbre|cbs|ceb|center|ceo|cern|cfa|cfd|chanel|channel|chase|chat|cheap|chintai|chloe|christmas|chrome|chrysler|church|cipriani|circle|cisco|citadel|citi|citic|city|cityeats|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|coach|codes|coffee|college|cologne|comcast|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cookingchannel|cool|corsica|country|coupon|coupons|courses|credit|creditcard|creditunion|cricket|crown|crs|cruise|cruises|csc|cuisinella|cymru|cyou|dabur|dad|dance|date|dating|datsun|day|dclk|dds|deal|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|dhl|diamonds|diet|digital|direct|directory|discount|discover|dish|diy|dnp|docs|dodge|dog|doha|domains|dot|download|drive|dstv|dtv|dubai|duck|dunlop|duns|dupont|durban|dvag|dwg|earth|eat|edeka|education|email|emerck|emerson|energy|engineer|engineering|enterprises|epost|epson|equipment|ericsson|erni|esq|estate|esurance|etisalat|eurovision|eus|events|everbank|exchange|expert|exposed|express|extraspace|fage|fail|fairwinds|faith|family|fan|fans|farm|farmers|fashion|fast|fedex|feedback|ferrari|ferrero|fiat|fidelity|fido|film|final|finance|financial|fire|firestone|firmdale|fish|fishing|fit|fitness|flickr|flights|flir|florist|flowers|flsmidth|fly|foo|foodnetwork|football|ford|forex|forsale|forum|foundation|fox|free|fresenius|frl|frogans|frontdoor|frontier|ftr|fujitsu|fujixerox|fun|fund|furniture|futbol|fyi|gal|gallery|gallo|gallup|game|games|gap|garden|gbiz|gdn|gea|gent|genting|george|ggee|gift|gifts|gives|giving|glade|glass|gle|global|globo|gmail|gmbh|gmo|gmx|godaddy|gold|goldpoint|golf|goo|goodhands|goodyear|goog|google|gop|got|gotv|grainger|graphics|gratis|green|gripe|group|guardian|gucci|guge|guide|guitars|guru|hair|hamburg|hangout|haus|hbo|hdfc|hdfcbank|health|healthcare|help|helsinki|here|hermes|hgtv|hiphop|hisamitsu|hitachi|hiv|hkt|hockey|holdings|holiday|homedepot|homegoods|homes|homesense|honda|honeywell|horse|host|hosting|hot|hoteles|hotmail|house|how|hsbc|htc|hughes|hyatt|hyundai|ibm|icbc|ice|icu|ieee|ifm|iinet|ikano|imamat|imdb|immo|immobilien|industries|infiniti|ing|ink|institute|insurance|insure|intel|international|intuit|investments|ipiranga|irish|iselect|ismaili|ist|istanbul|itau|itv|iveco|iwc|jaguar|java|jcb|jcp|jeep|jetzt|jewelry|jio|jlc|jll|jmp|jnj|joburg|jot|joy|jpmorgan|jprs|juegos|juniper|kaufen|kddi|kerryhotels|kerrylogistics|kerryproperties|kfh|kia|kim|kinder|kindle|kitchen|kiwi|koeln|komatsu|kosher|kpmg|kpn|krd|kred|kuokgroup|kyknet|kyoto|lacaixa|ladbrokes|lamborghini|lamer|lancaster|lancia|lancome|land|landrover|lanxess|lasalle|lat|latino|latrobe|law|lawyer|lds|lease|leclerc|lefrak|legal|lego|lexus|lgbt|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|lilly|limited|limo|lincoln|linde|link|lipsy|live|living|lixil|loan|loans|locker|locus|loft|lol|london|lotte|lotto|love|lpl|lplfinancial|ltd|ltda|lundbeck|lupin|luxe|luxury|macys|madrid|maif|maison|makeup|man|management|mango|market|marketing|markets|marriott|marshalls|maserati|mattel|mba|mcd|mcdonalds|mckinsey|med|media|meet|melbourne|meme|memorial|men|menu|meo|metlife|miami|microsoft|mini|mint|mit|mitsubishi|mlb|mls|mma|mnet|mobily|moda|moe|moi|mom|monash|money|monster|montblanc|mopar|mormon|mortgage|moscow|moto|motorcycles|mov|movie|movistar|msd|mtn|mtpc|mtr|multichoice|mutual|mutuelle|mzansimagic|nab|nadex|nagoya|naspers|nationwide|natura|navy|nba|nec|netbank|netflix|network|neustar|new|newholland|news|next|nextdirect|nexus|nfl|ngo|nhk|nico|nike|nikon|ninja|nissan|nissay|nokia|northwesternmutual|norton|now|nowruz|nowtv|nra|nrw|ntt|nyc|obi|observer|off|office|okinawa|olayan|olayangroup|oldnavy|ollo|omega|one|ong|onl|online|onyourside|ooo|open|oracle|orange|organic|orientexpress|origins|osaka|otsuka|ott|ovh|page|pamperedchef|panasonic|panerai|paris|pars|partners|parts|party|passagens|pay|payu|pccw|pet|pfizer|pharmacy|philips|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pioneer|pizza|place|play|playstation|plumbing|plus|pnc|pohl|poker|politie|porn|pramerica|praxi|press|prime|prod|productions|prof|progressive|promo|properties|property|protection|pru|prudential|pub|pwc|qpon|quebec|quest|qvc|racing|raid|read|realestate|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|reliance|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|richardli|ricoh|rightathome|ril|rio|rip|rmit|rocher|rocks|rodeo|rogers|room|rsvp|ruhr|run|rwe|ryukyu|saarland|safe|safety|sakura|sale|salon|samsclub|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|save|saxo|sbi|sbs|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scjohnson|scor|scot|seat|secure|security|seek|select|sener|services|ses|seven|sew|sex|sexy|sfr|shangrila|sharp|shaw|shell|shia|shiksha|shoes|shopping|shouji|show|showtime|shriram|silk|sina|singles|site|ski|skin|sky|skype|sling|smart|smile|sncf|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|srl|srt|stada|staples|star|starhub|statebank|statefarm|statoil|stc|stcgroup|stockholm|storage|store|stream|studio|study|style|sucks|supersport|supplies|supply|support|surf|surgery|suzuki|swatch|swiftcover|swiss|sydney|symantec|systems|tab|taipei|talk|taobao|target|tatamotors|tatar|tattoo|tax|taxi|tci|tdk|team|tech|technology|telecity|telefonica|temasek|tennis|teva|thd|theater|theatre|theguardian|tiaa|tickets|tienda|tiffany|tips|tires|tirol|tjmaxx|tjx|tkmaxx|tmall|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|trade|trading|training|travelchannel|travelers|travelersinsurance|trust|trv|tube|tui|tunes|tushu|tvs|ubank|ubs|uconnect|unicom|university|uno|uol|ups|vacations|vana|vanguard|vegas|ventures|verisign|versicherung|vet|viajes|video|vig|viking|villas|vin|vip|virgin|visa|vision|vista|vistaprint|viva|vivo|vlaanderen|vodka|volkswagen|volvo|vote|voting|voto|voyage|vuelos|wales|walmart|walter|wang|wanggou|warman|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weibo|weir|whoswho|wien|wiki|williamhill|win|windows|wine|winners|wme|wolterskluwer|woodside|work|works|world|wow|wtc|wtf|xbox|xerox|xfinity|xihuan|xin|कॉम|セール|佛山|慈善|集团|在线|大众汽车|点看|คอม|八卦|موقع|一号店|公益|公司|香格里拉|网站|移动|我爱你|москва|католик|онлайн|сайт|联通|קום|时尚|微博|淡马锡|ファッション|орг|नेट|ストア|삼성|商标|商店|商城|дети|ポイント|新闻|工行|家電|كوم|中文网|中信|娱乐|谷歌|電訊盈科|购物|クラウド|通販|网店|संगठन|餐厅|网络|ком|诺基亚|食品|飞利浦|手表|手机|ارامكو|العليان|اتصالات|بازار|موبايلي|ابوظبي|كاثوليك|همراه|닷컴|政府|شبكة|بيتك|عرب|机构|组织机构|健康|рус|珠宝|大拿|みんな|グーグル|世界|書籍|网址|닷넷|コム|天主教|游戏|vermögensberater|vermögensberatung|企业|信息|嘉里大酒店|嘉里|广东|政务|xperia|xyz|yachts|yahoo|yamaxun|yandex|yodobashi|yoga|yokohama|you|youtube|yun|zappos|zara|zero|zip|zippo|zone|zuerich'.split('|');\n  var defaults = {\n    html: false,\n    wiki: false,       // TODO: check all cases\n    markdown: false,   // TODO: check all cases\n    hashtags: true,\n    mentions: true,\n    emails: true,\n    links: {\n      protocols: true,\n      www: false,\n      tlds: {}\n    }\n  };\n  /* TODO: add more named HTML entities */\n  var HTML_ENTITIES = { nbsp: ' ', quot: '\"', gt: '>', lt: '<', amp: '&', ndash: '–' };\n\n  for (var i = 0; i < TLDs.length; i++) {\n    defaults.links.tlds[TLDs[i]] = true;\n  }\n\n  /**\n   * Токен, соответствующий некоторой подстроке в представленном на вход тексте.\n   *\n   * @constructor\n   * @property {string} type Тип токена.\n   * @property {string} subType Подтип токена.\n   * @property {number} st Индекс первого символа, входящего в токен.\n   * @property {number} en Индекс последнего символа, входящего в токен.\n   * @property {number} length Длина токена.\n   * @property {boolean} firstUpper True, если первый символ токена является заглавной буквой.\n   * @property {boolean} allUpper True, если все символы в токене являются заглавными буквами.\n   */\n  var Token = function(source, st, length, index, firstUpper, allUpper, type, subType) {\n    this.source = source;\n    this.st = st;\n    this.length = length;\n    this.index = index;\n    this.firstUpper = firstUpper;\n    this.allUpper = allUpper;\n    this.type = type;\n    if (subType) {\n      this.subType = subType;\n    }\n  }\n  Token.prototype.toString = function() {\n    return (('_str' in this) && (this._str.length == this.length)) ? this._str : (this._str = this.source.substr(this.st, this.length));\n  }\n  Token.prototype.indexOf = function(str) {\n    if (str.length == 1) {\n      for (var i = 0; i < this.length; i++) {\n        if (this.source[this.st + i] == str) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    return this.toString().indexOf(str);\n  }\n  Token.prototype.toLowerCase = function() {\n    return this.toString().toLocaleLowerCase();\n  }\n  Token.prototype.isCapitalized = function() {\n    return this.firstUpper && !this.allUpper;\n  }\n  Token.prototype.en = function() {\n    return this.st + this.length - 1;\n  }\n\n  /**\n   * Создает токенизатор текста с заданными опциями.\n   *\n   * @playground\n   * var Az = require('az');\n   * var tokens = Az.Tokens('Текст (от лат. textus — «ткань; сплетение, связь, паутина, сочетание») — зафиксированная на каком-либо материальном носителе человеческая мысль; в общем плане связная и полная последовательность символов.');\n   * tokens.done();\n   * @constructor\n   * @param {string} [text] Строка для разбивки на токены.\n   * @param {Object} [config] Опции, применяемые при разбивке.\n   * @param {boolean} [config.html=False] Распознавать и выделять в отдельные\n   *  токены (типа TAG) HTML-теги. Кроме того, содержимое тегов &lt;style&gt;\n   *  и &lt;script&gt; будет размечено как единый токен типа CONTENT.\n   * @param {boolean} [config.wiki=False] Распознавать и выделять в отдельные\n   *  токены элементы вики-разметки.\n   * @param {boolean} [config.markdown=False] Распознавать и выделять в отдельные\n   *  токены элементы Markdown-разметки.\n   * @param {boolean} [config.hashtags=True] Распознавать и выделять в отдельные\n   *  токены хэштеги (строки, начинающиеся с символа «#»).\n   * @param {boolean} [config.mentions=True] Распознавать и выделять в отдельные\n   *  токены упоминания (строки, начинающиеся с символа «@»).\n   * @param {boolean} [config.emails=True] Распознавать и выделять в отдельные\n   *  токены е-мейлы (нет, распознавание всех корректных по RFC адресов не\n   *  гарантируется).\n   * @param {Object} [config.links] Настройки распознавания ссылок. False, чтобы\n   *  не распознавать ссылки совсем.\n   * @param {boolean} [config.links.protocols=True] Распознавать и выделять в отдельные\n   *  токены ссылки с указанным протоколом (http://, https:// и вообще любым другим).\n   * @param {boolean} [config.links.www=False] Распознавать и выделять в отдельные\n   *  токены ссылки, начинающиеся с «www.».\n   * @param {Object} [config.links.tlds] Объект, в котором ключами должны быть\n   *  домены верхнего уровня, в которых будут распознаваться ссылки. По умолчанию\n   *  текущий список всех таких доменов.\n   * @memberof Az\n   */\n  var Tokens = function(text, config) {\n    if (this instanceof Tokens) {\n      this.tokens = [];\n      this.source = '';\n      if (typeof text == 'string') {\n        this.config = config ? Az.extend(defaults, config) : defaults;\n        this.append(text);\n      } else {\n        this.config = text ? Az.extend(defaults, text) : defaults;\n      }\n      this.index = -1;\n    } else {\n      return new Tokens(text, config);\n    }\n  }\n\n  Tokens.WORD = new String('WORD');\n  Tokens.NUMBER = new String('NUMBER');\n  Tokens.OTHER = new String('OTHER');\n  Tokens.DIGIT = new String('DIGIT');\n  Tokens.CYRIL = new String('CYRIL');\n  Tokens.LATIN = new String('LATIN');\n  Tokens.MIXED = new String('MIXED');\n  Tokens.PUNCT = new String('PUNCT');\n  Tokens.SPACE = new String('SPACE');\n  Tokens.MARKUP = new String('MARKUP');\n  Tokens.NEWLINE = new String('NEWLINE');\n  Tokens.EMAIL = new String('EMAIL');\n  Tokens.LINK = new String('LINK');\n  Tokens.HASHTAG = new String('HASHTAG');\n  Tokens.MENTION = new String('MENTION');\n  Tokens.TAG = new String('TAG');\n  Tokens.CONTENT = new String('CONTENT');\n  Tokens.SCRIPT = new String('SCRIPT');\n  Tokens.STYLE = new String('STYLE');\n  Tokens.COMMENT = new String('COMMENT');\n  Tokens.CLOSING = new String('CLOSING');\n  Tokens.TEMPLATE = new String('TEMPLATE');\n  Tokens.RANGE = new String('RANGE');\n  Tokens.ENTITY = new String('ENTITY');\n\n  /**\n   * Отправляет ещё один кусок текста на токенизацию. Таким образом вполне\n   * допустимо обрабатывать большие документы частями, многократно вызывая этот\n   * метод. При этом токен может начаться в одной части и продолжиться в\n   * следующей (а закончиться в ещё одной).\n   *\n   * @param {string} text Строка для разбивки на токены.\n   * @param {Object} [config] Опции, применяемые при разбивке. Перекрывают\n   *  опции, заданные в конструкторе токенизатора.\n   * @see Tokens\n   */\n  Tokens.prototype.append = function(text, config) {\n    'use strict';\n    // Для производительности:\n    // - как можно меньше операций конкатенции/разбивки строк\n    // - вместо сравнения всего токена, проверяем соответствующий ему символ в исходной строке\n    // - типы токенов - константы в Tokens, формально это строки, но сравниваем через === (как объекты)\n    config = config ? Az.extend(this.config, config) : this.config;\n    if (config.links && (config.links.tlds === true)) {\n      config.links.tlds = defaults.links.tlds;\n    }\n\n    var offs = this.source.length;\n    this.source += text;\n    \n    var s = this.source, ts = this.tokens;\n    for (var i = offs; i < s.length; i++) {\n      var ch = s[i];\n      var code = s.charCodeAt(i);\n\n      var append = false;\n      var last = ts.length - 1;\n      var token = ts[last];\n      var st = i;\n\n      if (config.html && (ch == ';')) {\n        // &nbsp;\n        if ((last > 0) && \n            (token.type === Tokens.WORD) && \n            (ts[last - 1].length == 1) && \n            (s[ts[last - 1].st] == '&')) {\n          var name = token.toLowerCase();\n          if (name in HTML_ENTITIES) {\n            ch = HTML_ENTITIES[name];\n            code = ch.charCodeAt(0);\n\n            last -= 2;\n            token = ts[last];\n            ts.length = last + 1;\n          }\n        } else\n        // &x123AF5;\n        // &1234;\n        if ((last > 1) && \n            ((token.type === Tokens.NUMBER) || \n             ((token.type === Tokens.WORD) &&\n              (s[token.st] == 'x'))) && \n            (ts[last - 1].length == 1) &&\n            (s[ts[last - 1].st] == '#') && \n            (ts[last - 1].length == 1) &&\n            (s[ts[last - 1].st] == '&')) {\n          if (s[token.st] == 'x') {\n            code = parseInt(token.toString().substr(1), 16);\n          } else {\n            code = parseInt(token.toString(), 10);\n          }\n          ch = String.fromCharCode(code);\n\n          last -= 3;\n          token = ts[last];\n          ts.length = last + 1;\n        }\n      }\n\n      var charType = Tokens.OTHER;\n      var charUpper = (ch.toLocaleLowerCase() != ch);\n      if (code >= 0x0400 && code <= 0x04FF) charType = Tokens.CYRIL;\n      if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A) || (code >= 0x00C0 && code <= 0x024F)) charType = Tokens.LATIN;\n      if (code >= 0x0030 && code <= 0x0039) charType = Tokens.DIGIT;\n      if ((code <= 0x0020) || (code >= 0x0080 && code <= 0x00A0)) charType = Tokens.SPACE;\n      if ('‐-−‒–—―.…,:;?!¿¡()[]«»\"\\'’‘’“”/⁄'.indexOf(ch) > -1) charType = Tokens.PUNCT;\n\n      var tokenType = charType;\n      var tokenSubType = false;\n      if (charType === Tokens.CYRIL || charType === Tokens.LATIN) {\n        tokenType = Tokens.WORD;\n        tokenSubType = charType;\n      } else\n      if (charType === Tokens.DIGIT) {\n        tokenType = Tokens.NUMBER;\n      }\n\n      var lineStart = !token || (s[token.st + token.length - 1] == '\\n');\n\n      if (config.wiki) {\n        if (lineStart) {\n          if (':;*#~|'.indexOf(ch) > -1) {\n            tokenType = Tokens.MARKUP;\n            tokenSubType = Tokens.NEWLINE;\n          }\n        }\n        if ('={[|]}'.indexOf(ch) > -1) {\n          tokenType = Tokens.MARKUP;\n        }\n      }\n\n      if (config.markdown) {\n        if (lineStart) {\n          if ('=-#>+-'.indexOf(ch) > -1) {\n            tokenType = Tokens.MARKUP;\n            tokenSubType = Tokens.NEWLINE;\n          }\n        }\n        if ('[]*~_`\\\\'.indexOf(ch) > -1) {\n          tokenType = Tokens.MARKUP;\n        }\n      }\n\n      if (token) {\n        if (config.wiki && \n            (ch != \"'\") && \n            (token.length == 1) &&\n            (s[token.st] == \"'\") &&\n            (last > 0) &&\n            (ts[last - 1].type === Tokens.WORD) &&\n            (ts[last - 1].subType === Tokens.LATIN)) {\n          ts[last - 1].length += token.length;\n\n          last -= 1;\n          ts.length = last + 1;\n          token = ts[last];\n        }\n\n        // Preprocess last token\n        if (config.links && \n            config.links.tlds &&\n            ((charType === Tokens.PUNCT) || \n             (charType === Tokens.SPACE)) &&\n            (ts.length > 2) &&\n            (ts[last - 2].type === Tokens.WORD) &&\n            (ts[last - 1].length == 1) &&\n            (s[ts[last - 1].st] == '.') &&\n            (ts[last].type === Tokens.WORD) &&\n            (token.toString() in config.links.tlds)) {\n\n          // Merge all subdomains\n          while ((last >= 2) &&\n                 (ts[last - 2].type === Tokens.WORD) &&\n                 (ts[last - 1].length == 1) &&\n                 ((s[ts[last - 1].st] == '.') || \n                  (s[ts[last - 1].st] == '@') || \n                  (s[ts[last - 1].st] == ':'))) {\n            last -= 2;\n            token = ts[last];\n            token.length += ts[last + 1].length + ts[last + 2].length;\n            token.allUpper = token.allUpper && ts[last + 1].allUpper && ts[last + 2].allUpper;\n          }\n\n          if (config.emails && \n              (token.indexOf('@') > -1) && \n              (token.indexOf(':') == -1)) {\n            // URL can contain a '@' but in that case it should be in form http://user@site.com or user:pass@site.com\n            // So if URL has a '@' but no ':' in it, we assume it's a email\n            token.type = Tokens.EMAIL;\n          } else {\n            token.type = Tokens.LINK;\n\n            if (ch == '/') {\n              append = true;\n            }\n          }\n          ts.length = last + 1;\n        } else\n\n        // Process next char (start new token or append to the previous one)\n        if (token.type === Tokens.LINK) {\n          if ((ch == ')') && \n              (last >= 1) && \n              (ts[last - 1].type === Tokens.MARKUP) &&\n              (ts[last - 1].length == 1) &&\n              (s[ts[last - 1].st] == '(')) {\n            tokenType = Tokens.MARKUP;\n          } else\n          if ((charType !== Tokens.SPACE) && (ch != ',') && (ch != '<')) {\n            append = true;\n          }\n        } else\n        if (token.type === Tokens.EMAIL) {\n          if ((charType === Tokens.CYRIL) || (charType === Tokens.LATIN) || (ch == '.')) {\n            append = true;\n          }\n        } else\n        if ((token.type === Tokens.HASHTAG) || (token.type === Tokens.MENTION)) {\n          if ((charType === Tokens.CYRIL) || \n              (charType == Tokens.LATIN) || \n              (charType == Tokens.DIGIT) || \n              (ch == '_') || ((ch == '@') && (token.indexOf('@') == -1))) {\n            append = true;\n          }\n        } else\n        if ((token.type === Tokens.TAG) && (token.quote || (s[token.en()] != '>'))) {\n          append = true;\n          if (token.quote) {\n            if ((ch == token.quote) && (s[token.en()] != '\\\\')) {\n              delete token.quote;\n            }\n          } else\n          if ((ch == '\"') || (ch == \"'\")) {\n            token.quote = ch;\n          }\n        } else\n        if (token.type === Tokens.CONTENT) {\n          append = true;\n          if (token.quote) {\n            if ((ch == token.quote) && (s[token.en()] != '\\\\')) {\n              delete token.quote;\n            }\n          } else\n          if ((ch == '\"') || (ch == \"'\")) {\n            token.quote = ch;\n          } else\n          if (ch == '>') {\n            if ((token.length >= 8) && (token.toString().substr(-8) == '</script')) {\n              token.length -= 8;\n              st -= 8;\n\n              append = false;\n              tokenType = Tokens.TAG;\n              tokenSubType = Tokens.CLOSING;\n            } else \n            if ((token.length >= 7) && (token.toString().substr(-7) == '</style')) {\n              token.length -= 7;\n              st -= 7;\n\n              append = false;\n              tokenType = Tokens.TAG;\n              tokenSubType = Tokens.CLOSING;\n            } \n          }\n        } else\n        if ((token.type === Tokens.TAG) && \n            (token.type !== Tokens.CLOSING) &&\n            (token.length >= 8) &&\n            (token.toLowerCase().substr(1, 6) == 'script')) {\n          tokenType = Tokens.CONTENT;\n          tokenSubType = Tokens.SCRIPT;\n        } else\n        if ((token.type === Tokens.TAG) && \n            (token.type !== Tokens.CLOSING) &&\n            (token.length >= 7) && \n            (token.toLowerCase().substr(1, 5) == 'style')) {\n          tokenType = Tokens.CONTENT;\n          tokenSubType = Tokens.STYLE;\n        } else\n        if (config.html && \n            (token.length == 1) &&\n            (s[token.st] == '<') && \n            ((charType === Tokens.LATIN) || (ch == '!') || (ch == '/'))) {\n          append = true;\n          token.type = Tokens.TAG;\n          if (ch == '!') {\n            token.subType = Tokens.COMMENT;\n          } else\n          if (ch == '/') {\n            token.subType = Tokens.CLOSING;\n          }\n        } else\n        if (token.type === Tokens.CONTENT) {\n          append = true;\n        } else\n        if ((token.type === Tokens.MARKUP) && \n            (token.subType == Tokens.TEMPLATE) && \n            ((s[token.en()] != '}') || \n             (s[token.en() - 1] != '}'))) {\n          append = true;\n        } else\n        if ((token.type === Tokens.MARKUP) && \n            (token.type === Tokens.LINK) && \n            (s[token.en()] != ')')) {\n          append = true;\n        } else\n        if ((token.type === Tokens.MARKUP) && \n            (s[token.st] == '`') && \n            (token.subType === Tokens.NEWLINE) &&\n            (charType === Tokens.LATIN)) {\n          append = true;\n        } else\n        if ((charType === Tokens.CYRIL) || (charType === Tokens.LATIN)) {\n          if (token.type === Tokens.WORD) {\n            append = true;\n            token.subType = (token.subType == charType) ? token.subType : Tokens.MIXED;\n          } else\n          if (token.type === Tokens.NUMBER) { // Digits + ending\n            append = true;\n            token.subType = (token.subType && token.subType != charType) ? Tokens.MIXED : charType;\n          } else\n          if (config.hashtags && (token.length == 1) && (s[token.st] == '#')) { // Hashtags\n            append = true;\n            token.type = Tokens.HASHTAG;\n          } else\n          if (config.mentions && \n              (token.length == 1) && \n              (s[token.st] == '@') && \n              ((last == 0) || (ts[last - 1].type === Tokens.SPACE))) { // Mentions\n            append = true;\n            token.type = Tokens.MENTION;\n          } else\n          if ((charType === Tokens.LATIN) && \n              (token.length == 1) && \n              ((s[token.st] == \"'\") || (s[token.st] == '’'))) {\n            append = true;\n            token.type = Tokens.WORD;\n            token.subType = Tokens.LATIN;\n          } else\n          if ((token.length == 1) && (s[token.st] == '-')) { // -цать (?), 3-й\n            append = true;\n\n            if ((last > 0) && (ts[last - 1].type === Tokens.NUMBER)) {\n              token = ts[last - 1];\n              token.length += ts[last].length;\n\n              ts.length -= 1;\n            }\n\n            token.type = Tokens.WORD;\n            token.subType = charType;\n          }\n        } else\n        if (charType === Tokens.DIGIT) {\n          if (token.type === Tokens.WORD) {\n            append = true;\n            token.subType = Tokens.MIXED;\n          } else\n          if (token.type === Tokens.NUMBER) {\n            append = true;\n          } else\n          if ((token.length == 1) &&\n              ((s[token.st] == '+') || (s[token.st] == '-'))) {\n            append = true;\n\n            if ((last > 0) && (ts[last - 1].type === Tokens.NUMBER)) {\n              token = ts[last - 1];\n              token.length += ts[last].length;\n              token.subType = Tokens.RANGE;\n\n              ts.length -= 1;\n            }\n\n            token.type = Tokens.NUMBER;\n          } else\n          if ((token.length == 1) &&\n              ((s[token.st] == ',') || (s[token.st] == '.')) && \n              (ts.length > 1) && \n              (ts[last - 1].type === Tokens.NUMBER)) {\n            append = true;\n\n            token = ts[last - 1];\n            token.length += ts[last].length;\n\n            ts.length -= 1;\n          }\n        } else\n        if (charType === Tokens.SPACE) {\n          if (token.type === Tokens.SPACE) {\n            append = true;\n          }\n        } else\n        if ((token.type === Tokens.MARKUP) && \n            (s[token.st] == ch) &&\n            ('=-~:*#`\\'>_'.indexOf(ch) > -1)) {\n          append = true;\n        } else\n        if (ch == '.') {\n          if (config.links && \n              config.links.www && \n              (token.length == 3) &&\n              (token.toLowerCase() == 'www')) { // Links without protocol but with www\n            append = true;\n            token.type = Tokens.LINK;\n          }\n        } else\n        if (config.wiki && (ch == \"'\") && (s[token.en()] == \"'\")) {\n          if (token.length > 1) {\n            token.length--;\n            st--;\n            tokenType = Tokens.MARKUP;\n          } else {\n            append = true;\n            token.type = Tokens.MARKUP;\n          }\n        } else\n        if ((ch == '-') || \n            ((token.subType == Tokens.LATIN) && \n             ((ch == '’') || (ch == \"'\")))) {\n          if (token.type === Tokens.WORD) {\n            append = true;\n          }\n        } else\n        if (ch == '/') {\n          if (config.links && \n              config.links.protocols &&\n              (ts.length > 2) &&\n              (ts[last - 2].type === Tokens.WORD) &&\n              (ts[last - 2].subType == Tokens.LATIN) &&\n              (ts[last - 1].length == 1) &&\n              (s[ts[last - 1].st] == ':') &&\n              (ts[last].length == 1) &&\n              (s[ts[last].st] == '/')) { // Links (with protocols)\n            append = true;\n\n            token = ts[last - 2];\n            token.length += ts[last - 1].length + ts[last].length;\n            token.allUpper = token.allUpper && ts[last - 1].allUpper && ts[last].allUpper;\n            token.type = Tokens.LINK;\n\n            ts.length -= 2;\n          }\n        } else\n        if (config.html && ch == ';') {\n          if ((last > 0) && \n              (token.type === Tokens.WORD) && \n              (ts[last - 1].length == 1) &&\n              (s[ts[last - 1].st] == '&')) {\n            append = true;\n\n            token = ts[last - 1];\n            token.length += ts[last].length;\n            token.allUpper = token.allUpper && ts[last - 1].allUpper;\n            token.type = Tokens.ENTITY;\n\n            ts.length -= 1;\n          } else\n          if ((last > 1) && \n              ((token.type === Tokens.WORD) || \n               (token.type === Tokens.NUMBER)) && \n              (ts[last - 1].length == 1) &&\n              (s[ts[last - 1].st] == '#') && \n              (ts[last - 2].length == 1) &&\n              (s[ts[last - 2].st] == '&')) {\n            append = true;\n\n            token = ts[last - 2];\n            token.length += ts[last - 1].length + ts[last].length;\n            token.allUpper = token.allUpper && ts[last - 1].allUpper && ts[last].allUpper;\n            token.type = Tokens.ENTITY;\n\n            ts.length -= 2;\n          }\n        } else\n        if (config.markdown && \n            (ch == '[') && \n            (token.length == 1) &&\n            (s[token.st] == '!')) {\n          append = true;\n          token.type = Tokens.MARKUP;\n        } else\n        if (config.markdown && \n            (ch == '(') &&\n            (token.length == 1) &&\n            (s[token.st] == ']')) {\n          tokenType = Tokens.MARKUP;\n          tokenSubType = Tokens.LINK;\n        } else\n        if (config.wiki && \n            (ch == '{') &&\n            (token.length == 1) &&\n            (s[token.st] == '{')) {\n          append = true;\n          token.type = Tokens.MARKUP;\n          token.subType = Tokens.TEMPLATE;\n        } else\n        if (config.wiki && \n            (ch == '[') && \n            (token.length == 1) &&\n            (s[token.st] == '[')) {\n          append = true;\n        } else\n        if (config.wiki && \n            (ch == ']') && \n            (token.length == 1) &&\n            (s[token.st] == ']')) {\n          append = true;\n        } else\n        if (config.wiki && (ch == '|') && !lineStart) {\n          var found = -1;\n          for (var j = last - 1; j >= 0; j--) {\n            if ((ts[j].length == 2) && \n                (s[ts[j].st] == '[') && \n                (s[ts[j].st + 1] == '[')) {\n              found = j;\n              break;\n            }\n            if (((ts[j].length == 1) && \n                 (s[ts[j].st] == '|')) || \n                ts[j].indexOf('\\n') > -1) {\n              break;\n            }\n          }\n          if (found > -1) {\n            append = true;\n            for (var j = last - 1; j >= found; j--) {\n              token = ts[j];\n              token.length += ts[j + 1].length;\n              token.allUpper = token.allUpper && ts[j + 1].allUpper;\n            }\n            last = found;\n            ts.length = last + 1;\n            token.subType = Tokens.LINK;\n          }\n        }\n      }\n\n      if (append) {\n        token.length++;\n        token.allUpper = token.allUpper && charUpper;\n      } else {\n        token = new Token(s, st, i + 1 - st, ts.length, charUpper, charUpper, tokenType, tokenSubType);\n        ts.push(token);\n      }\n    }\n    return this;\n  }\n\n  function alwaysTrue() {\n    return true;\n  }\n\n  function getMatcher(filter, exclude) {\n    if (!filter) {\n      return alwaysTrue();\n    }\n    if (typeof filter == 'function') {\n      return filter;\n    }\n    var types = filter;\n    var exclusive;\n    if ('length' in filter) {\n      exclusive = !exclude;\n      types = {};\n      for (var i = 0; i < filter.length; i++) {\n        types[filter[i]] = true;\n      }\n    } else {\n      exclusive = exclude;\n      exclude = false;\n    }\n    return function(token, index, array) {\n      if (token.subType) {\n        var sub = token.type + '.' + token.subType;\n        if (sub in types) {\n          return types[sub] != exclude;\n        }\n      }\n      if (token.type in types) {\n        return types[token.type] != exclude;\n      } else {\n        return !exclusive;\n      }\n    }\n  }\n\n  /**\n   * Завершает токенизацию, возвращая список токенов.\n   *\n   * Эта и другие функции принимают последними параметрами filter и флаг exclude. Они\n   * служат для фильтрации токенов (потому что часто удобнее получать не все токены, а\n   * только определенную часть из них).\n   *\n   * Если в filter передана функция, то параметр exclude игнорируется, а filter вызывается\n   * аналогично коллбэку в методе Array.prototype.filter: ей передаются параметры\n   * token, index, array (текущий токен, его индекс и общий список токенов). Будут\n   * возвращены только токены, для которых функция вернет истинное значение.\n   *\n   * Если в filter передан массив (или объект с полем length), то возвращаются токены, типы\n   * которых либо входят в этот массив (exclude=false), либо не входят в него (exclude=true).\n   * Вместо типов можно использовать строки вида 'WORD.LATIN' (тип, символ «точка» и подтип).\n   *\n   * Если в filter передать объект, то ключами в нём должны быть типы токенов, а значениями -\n   * true или false в зависимости от того, включать такие токены в ответ или нет. Как и в случае случае\n   * с массивом, в качестве ключей можно использовать строки вида 'WORD.LATIN'.\n   * Здесь параметр exclude означает, следует ли ограничить выдачу только теми типами, которые\n   * перечислены в filter.\n   * Значения с указанием подтипа имеют больший приоритет, чем просто типы. Благодаря этому можно\n   * делать такие странные вещи:\n   *\n   * ```\n   * t.done({ 'WORD': false, 'WORD.LATIN': true }, false);\n   * ```\n   * (то есть вернуть все теги, кроме тегов с типом WORD, но включить теги с подтипом LATIN)\n   *\n   * @param {Function|String[]|Object} [filter] Типы токенов, по которым нужно\n   *  отфильтровать результат (или функция для фильтрации).\n   * @param {boolean} [exclude=False] Инвертирует фильтр, т.е. возвращаются\n   *  токены со всеми типами, за исключением перечисленных в filter.\n   * @returns {Token[]} Список токенов после фильтрации.\n   */\n  Tokens.prototype.done = function(filter, exclude) {\n    // Finalize tokenizing, return list of tokens\n    // For now it just returns tokens, in the future there could be some additional work\n    if (!filter) {\n      return this.tokens;\n    }\n    var matcher = getMatcher(filter, exclude);\n    var list = [];\n    for (var i = 0; i < this.tokens.length; i++) {\n      if (matcher(this.tokens[i], i, this.tokens)) {\n        list.push(this.tokens[i]);\n      }\n    }\n    return list;\n  }\n\n  /**\n   * Подсчитывает текущее количество токенов.\n   *\n   * @param {Function|String[]|Object} [filter] См. описание метода done.\n   * @param {boolean} [exclude=False] См. описание метода done.\n   * @returns {Number} Число токенов после фильтрации.\n   */\n  Tokens.prototype.count = function(filter, exclude) {\n    if (!filter) {\n      return this.tokens.length;\n    }\n    var matcher = getMatcher(filter, exclude);\n    var count = 0;\n    for (var i = 0; i < this.tokens.length; i++) {\n      if (matcher(this.tokens[i], i, this.tokens)) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Получает следующий токен относительно текущей позиции.\n   *\n   * @param {boolean} moveIndex Следует ли переместить указатель к\n   *  следующему токену (в противном случае следующий вызов nextToken вернет\n   *  тот же результат)\n   * @param {Function|String[]|Object} [filter] См. описание метода done.\n   * @param {boolean} [exclude=False] См. описание метода done.\n   * @returns {Token|null} Следующий токен или null, если подходящих токенов\n   *  впереди нет.\n   */\n  Tokens.prototype.nextToken = function(moveIndex, filter, exclude) {\n    var matcher = getMatcher(filter, exclude);\n    var index = this.index;\n    index++;\n    while (index < this.tokens.length && matcher(this.tokens[index], index, this.tokens)) {\n      index++;\n    }\n    if (index < this.tokens.length) {\n      if (moveIndex) {\n        this.index = index;\n      }\n      return this.tokens[index];\n    }\n    return null;\n  }\n\n  /**\n   * Проверяет, является ли следующий (за исключением пробелов) токен знаком\n   * препинания или нет.\n   *\n   * @returns {Token|False} False, если следующий токен не является знаком\n   *  препинания, либо сам токен в противном случае.\n   */\n  Tokens.prototype.punctAhead = function() {\n    var token = this.nextToken(false, ['SPACE'], true);\n    return token && token.type == 'PUNCT' && token;\n  }\n\n  /**\n   * Получает предыдущий токен относительно текущей позиции.\n   *\n   * @param {boolean} moveIndex Следует ли переместить указатель к\n   *  предыдущему токену (в противном случае следующий вызов prevToken вернет\n   *  тот же результат)\n   * @param {Function|String[]|Object} [filter] См. описание метода done.\n   * @param {boolean} [exclude=False] См. описание метода done.\n   * @returns {Token|null} Предыдущий токен или null, если подходящих токенов\n   *  позади нет.\n   */\n  Tokens.prototype.prevToken = function(moveIndex, filter, exclude) {\n    var matcher = getMatcher(filter, exclude);\n    var index = this.index;\n    index--;\n    while (index >= 0 && matcher(this.tokens[index], index, this.tokens)) {\n      index--;\n    }\n    if (index >= 0) {\n      if (moveIndex) {\n        this.index = index;\n      }\n      return this.tokens[index];\n    }\n    return null;\n  }\n\n  /**\n   * Проверяет, является ли предыдущий (за исключением пробелов) токен знаком\n   * препинания или нет.\n   *\n   * @returns {Token|False} False, если предыдущий токен не является знаком\n   *  препинания, либо сам токен в противном случае.\n   */\n  Tokens.prototype.punctBehind = function() {\n    var token = this.prevToken(false, ['SPACE'], true);\n    return token && token.type == 'PUNCT' && token;\n  }\n\n  /**\n   * Проверяет, есть ли впереди текущей позиции токены, удовлетворяющие фильтру.\n   *\n   * @param {Function|String[]|Object} [filter] См. описание метода done.\n   * @param {boolean} [exclude=False] См. описание метода done.\n   * @returns {boolean} True если впереди есть хотя бы один подходящий токен,\n   *  и False в противном случае.\n   */\n  Tokens.prototype.hasTokensAhead = function(filter, exclude) {\n    return this.nextToken(false, filter, exclude) != null;\n  }\n\n  /**\n   * Проверяет, есть ли позади текущей позиции токены, удовлетворяющие фильтру.\n   *\n   * @param {Function|String[]|Object} [filter] См. описание метода done.\n   * @param {boolean} [exclude=False] См. описание метода done.\n   * @returns {boolean} True если позади есть хотя бы один подходящий токен,\n   *  и False в противном случае.\n   */\n  Tokens.prototype.hasTokensBehind = function(filter, exclude) {\n    return this.prevToken(false, filter, exclude) != null;\n  }\n\n  return Tokens;\n}));\n","let array = {\"ru\": [\n    \"блядина\",\n    \"чушка\",\n    \"куни\",\n    \"жидоебское\",\n    \"тварь\",\n    \"мымра\",\n    \"выблядок\",\n    \"алкоголик\",\n    \"зануда\",\n    \"пендосия\",\n    \"сука\",\n    \"пидор\",\n    \"страхоебище\",\n    \"срака\",\n    \"бомж\",\n    \"стоячек\",\n    \"взбляд\",\n    \"святоша\",\n    \"алень\",\n    \"пиздоблошка\",\n    \"хуедин\",\n    \"нихуя\",\n    \"голуби\",\n    \"пришью\",\n    \"гнойный\",\n    \"блядский\",\n    \"наебнуться\",\n    \"мухосоранск\",\n    \"елдак\",\n    \"наеб\",\n    \"хуеман\",\n    \"хуйня\",\n    \"доебались\",\n    \"выебон\",\n    \"хуле\",\n    \"волосня\",\n    \"чучмен\",\n    \"обламаться\",\n    \"мерхавеч\",\n    \"барыга\",\n    \"дерьмоед\",\n    \"ебанулось\",\n    \"дупло\",\n    \"присунуть\",\n    \"ахуел\",\n    \"блядское\",\n    \"ебанько\",\n    \"манья\",\n    \"спиздить\",\n    \"ебанула\",\n    \"выблядовал\",\n    \"скотоеб\",\n    \"обосцать\",\n    \"однохуйственно\",\n    \"менты\",\n    \"наебнулась\",\n    \"ебнул\",\n    \"стоячок\",\n    \"блядская\",\n    \"распиздошила\",\n    \"блядство\",\n    \"шоха\",\n    \"жидоебский\",\n    \"дерьмохеропиздократия\",\n    \"прихуел\",\n    \"деревня\",\n    \"дурак\",\n    \"сволочь\",\n    \"писька\",\n    \"молокосос\",\n    \"злоебучий\",\n    \"опездол\",\n    \"радужный\",\n    \"дрянь\",\n    \"еблище\",\n    \"сексист\",\n    \"свинтус\",\n    \"жидоебка\",\n    \"многопиздная\",\n    \"трахнуть\",\n    \"пиздовладелец\",\n    \"ебля\",\n    \"нахуй\",\n    \"распиздяй\",\n    \"малолетка\",\n    \"голубятня\",\n    \"очко\",\n    \"передернуть\",\n    \"присунул\",\n    \"казел\",\n    \"импотент\",\n    \"хули\",\n    \"остоебать\",\n    \"писюн\",\n    \"мудозвод\",\n    \"член\",\n    \"хуйло\",\n    \"жополиз\",\n    \"подонок\",\n    \"наеб\",\n    \"говно\",\n    \"путана\",\n    \"заебала\",\n    \"допизды\",\n    \"елда\",\n    \"дерево\",\n    \"проститутка\",\n    \"отъебись\",\n    \"гнида\",\n    \"хитровыебанный\",\n    \"ебанный\",\n    \"ебаный\",\n    \"залупа\",\n    \"облом\",\n    \"вьебал\",\n    \"изъебнулся\",\n    \"ебни\",\n    \"жопа\",\n    \"выебнуться\",\n    \"мудила\",\n    \"пиздобратия\",\n    \"гобиться\",\n    \"педик\",\n    \"дура\",\n    \"бадяжить\",\n    \"деревеньщина\",\n    \"наблядовал\",\n    \"голубой\",\n    \"распиздяйка\",\n    \"капрофил\",\n    \"доебалась\",\n    \"ебкость\",\n    \"опиздоумел\",\n    \"хитровыебанная\",\n    \"говнюк\",\n    \"засранец\",\n    \"дерьмо\",\n    \"осед\",\n    \"заеб\",\n    \"целкa\",\n    \"еблан\",\n    \"ебанешься\",\n    \"ебанулся\",\n    \"гей\",\n    \"дерьмохеропиздократ\",\n    \"шлюха\",\n    \"пиздец\",\n    \"удавись\",\n    \"развалюха\",\n    \"шут\",\n    \"нахуярить\",\n    \"ебашит\",\n    \"прыщавый\",\n    \"выебывается\",\n    \"слоняра\",\n    \"обламатся\",\n    \"хер\",\n    \"феменистка\",\n    \"заебал\",\n    \"ебланка\",\n    \"крыса\",\n    \"фалос\",\n    \"фапать\",\n    \"гнусный\",\n    \"машонка\",\n    \"пидоростия\",\n    \"трахаться\",\n    \"пофапать\",\n    \"пиздрик\",\n    \"дуплоящер\",\n    \"вжопу\",\n    \"сцать\",\n    \"подъебки\",\n    \"объебала\",\n    \"яйчелы\",\n    \"наебали\",\n    \"объебал\",\n    \"косяк\",\n    \"хуелес\",\n    \"кощей\",\n    \"наебнулся\",\n    \"болван\",\n    \"черножепый\",\n    \"нахуяриться\",\n    \"остоебал\",\n    \"пиздецкое\",\n    \"одень\",\n    \"феменизм\",\n    \"алкаш\",\n    \"пизда\",\n    \"пондостания\",\n    \"уебался\",\n    \"хесосо\",\n    \"пасть\",\n    \"опущеный\",\n    \"деревянный\",\n    \"ебанул\",\n    \"ахуй\",\n    \"блядь\",\n    \"пиздодушие\",\n    \"объебали\",\n    \"пьянь\",\n    \"пиздецкий\",\n    \"пиздопляска\",\n    \"глупизди\",\n    \"оберблядь\",\n    \"спиздила\",\n    \"оскотоебился\",\n    \"хуевина\",\n    \"блядистость\",\n    \"пендос\",\n    \"пиздабол\",\n    \"козлоебина\",\n    \"изъебнуться\",\n    \"лох\",\n    \"трах\",\n    \"мамку\",\n    \"подпиздывает\",\n    \"кресты\",\n    \"некрофил\",\n    \"пендостан\",\n    \"мудачье\",\n    \"мудак\",\n    \"скотоебина\",\n    \"нигретов\",\n    \"жидоебские\",\n    \"насрать\",\n    \"свинья\",\n    \"стояк\",\n    \"ботаник\",\n    \"разъебали\",\n    \"спиздил\",\n    \"козлоеб\",\n    \"бурда\",\n    \"наркоту\",\n    \"рак\",\n    \"бля\",\n    \"сосать\",\n    \"писос\",\n    \"промежность\",\n    \"соска\",\n    \"пиздоебищность\",\n    \"обосцыш\",\n    \"ебало\",\n    \"дрянной\",\n    \"сосунок\",\n    \"заебать\",\n    \"падла\",\n    \"бляхомудия\",\n    \"уебалась\",\n    \"подзалупный\",\n    \"мондавошки\",\n    \"шестерка\",\n    \"уебище\",\n    \"жидоеб\",\n    \"нига\",\n    \"предатель\",\n    \"подофил\",\n    \"лолита\",\n    \"пендостания\",\n    \"пиздуй\",\n    \"долбаеб\",\n    \"пиздун\",\n    \"алкашная\",\n    \"мошонка\",\n    \"малоебущий\",\n    \"слон\",\n    \"распиздошить\",\n    \"трепездон\",\n    \"чухмен\",\n    \"доебался\",\n    \"пидорас\",\n    \"пидорасы\",\n    \"пиздобрат\",\n    \"подпиздываеть\",\n    \"нахуя\",\n    \"черт\",\n    \"прокаженный\",\n    \"козлоебище\",\n    \"уебаться\",\n    \"ебани\",\n    \"выебываться\",\n    \"гандон\",\n    \"греблядь\",\n    \"заебали\",\n    \"поебень\",\n    \"остоебала\",\n    \"остоебали\",\n    \"пиздецкая\",\n    \"пезды\",\n    \"похуй\",\n    \"балван\",\n    \"дегенерат\",\n    \"азер\",\n    \"голоебица\",\n    \"москали\",\n    \"пиздомания\",\n    \"гаишник\",\n    \"уебки\",\n    \"выебываются\",\n    \"трепездонит\",\n    \"халявочник\",\n    \"исчезни\",\n    \"секс\",\n    \"объебательство\",\n    \"блоха\",\n    \"впиздячил\",\n    \"пердун\",\n    \"выебываешься\",\n    \"уебищенски\",\n    \"факер\",\n    \"лабизаться\",\n    \"срачище\",\n    \"мордобой\",\n    \"окаченел\",\n    \"хуево\",\n    \"хуесос\",\n    \"хуесосы\",\n    \"сучара\",\n    \"сучары\",\n    \"наротан\",\n    \"минет\",\n    \"говносос\",\n    \"говнососы\",\n    \"гадушник\",\n    \"шароебится\",\n    \"халява\",\n    \"халявы\",\n    \"чмоха\",\n    \"нигер\",\n    \"нигеры\",\n    \"сучка\",\n    \"сучки\",\n    \"конченый\",\n    \"конченые\",\n    \"рачина\",\n    \"доебаться\",\n    \"наебашился\",\n    \"сосихуйский\",\n    \"ебать\",\n    \"ведьма\",\n    \"крышка\",\n    \"крысеныш\",\n    \"пидоростан\",\n    \"заебись\",\n    \"ченый\",\n    \"конча\",\n    \"дубина\",\n    \"очкун\",\n    \"москаль\",\n    \"долбаебка\",\n    \"косоебится\",\n    \"мондавошка\",\n    \"нимфоманка\",\n    \"ебанулась\",\n    \"подъебка\",\n    \"жидоебская\",\n    \"объебать\",\n    \"изъебнулась\",\n    \"трахал\",\n    \"наебщики\",\n    \"выебываться\",\n    \"косячок\",\n    \"мамка\",\n    \"запад\",\n    \"херотень\",\n    \"даун\",\n    \"хуй\",\n    \"чмо\",\n    \"чмошник\",\n    \"чмошная\",\n    \"чмошный\"\n]};\n\nmodule.exports = (clear=false)=>{\n    if(clear) return array.ru.filter(x=>!x.includes(\" \"));\n    return array.ru;\n}","// https://ru.wiktionary.org/wiki/%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5:%D0%A1%D0%BB%D0%B5%D0%BD%D0%B3_%D0%BD%D0%B0%D1%80%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%BE%D0%B2\n\nlet array = [\n    \"би-бах\",\n    \"гиблый\",\n    \"амфа\",\n    \"пекс\",\n    \"фен\",\n    \"шпикачка\",\n    \"паша-нюхарь\",\n    \"скоростюшка\",\n    \"шпреха\",\n    \"ноздрик\",\n    \"спиды\",\n    \"плюса\",\n    \"бырик\",\n    \"бырятина\",\n    \"быревич\",\n    \"бырюга\",\n    \"порох\",\n    \"шпиг\",\n    \"шпэк\",\n    \"спидулин\",\n    \"фэка\",\n    \"анестезиюшка\",\n    \"кетиш\",\n    \"антрацит\",\n    \"афганка\",\n    \"беленький\",\n    \"бутик\",\n    \"пляс-вода\",\n    \"оксик\",\n    \"бутират\",\n    \"бутерат\",\n    \"винт\",\n    \"анаша\",\n    \"баш\",\n    \"баха\",\n    \"беладонна\",\n    \"дубас\",\n    \"бо-бо\",\n    \"дудка\",\n    \"шмаль\",\n    \"шишки\",\n    \"срост\",\n    \"драп\",\n    \"дуст\",\n    \"каннабис\",\n    \"масть\",\n    \"сканк\",\n    \"шмале-волокно\",\n    \"рыжуха\",\n    \"нитротодаксин\",\n    \"ганджа\",\n    \"ганжа\",\n    \"ганджубас\",\n    \"ганя\",\n    \"сенсимилья\",\n    \"гаш\",\n    \"гашик\",\n    \"свежак\",\n    \"кэмчик\",\n    \"кэм\",\n    \"камон\",\n    \"кэмел\",\n    \"кирпич\",\n    \"аршин\",\n    \"хэш\",\n    \"ляпка\",\n    \"гаштет\",\n    \"герыч\",\n    \"гердос\",\n    \"герик\",\n    \"гертруда\",\n    \"хмурый\",\n    \"дэкс\",\n    \"декс\",\n    \"декстра\",\n    \"джараш\",\n    \"индусик\",\n    \"джанк\",\n    \"джеф\",\n    \"мулька\",\n    \"дичка\",\n    \"шала\",\n    \"шалапета\",\n    \"шалубень\",\n    \"шалубас\",\n    \"беспонтовка\",\n    \"нифель\",\n    \"бутер\",\n    \"порожняк\",\n    \"арычница\",\n    \"подзаборка\",\n    \"дурь\",\n    \"ешка\",\n    \"кайф\",\n    \"колеса\",\n    \"диски\",\n    \"бублики\",\n    \"крокодил\",\n    \"микродот\",\n    \"кислота\",\n    \"кислое\",\n    \"кисляк\",\n    \"лизер\",\n    \"лимон\",\n    \"кокс\",\n    \"кокос\",\n    \"иней\",\n    \"чума\",\n    \"драгстерия\",\n    \"крэк\",\n    \"куземяка\",\n    \"хмурь\",\n    \"говнишко\",\n    \"темный\",\n    \"медицина\",\n    \"кристалл\",\n    \"мет\",\n    \"метамфа\",\n    \"москва\",\n    \"настя\",\n    \"пончики\",\n    \"поника\",\n    \"гидра\",\n    \"гидрач\",\n    \"пыль\",\n    \"синя\",\n    \"синька\",\n    \"шустрый\",\n    \"быстрый\",\n    \"роп\",\n    \"солома\",\n    \"сонники\",\n    \"терп\",\n    \"терпинкод\",\n    \"коделак\",\n    \"трам\",\n    \"ханка\",\n    \"черняшка\",\n    \"федя\",\n    \"хуюха\",\n    \"табла\",\n    \"тапка\",\n    \"качели\",\n    \"ликвид\",\n    \"молочище\",\n    \"манага\",\n    \"маняга\",\n    \"молоко\",\n    \"молочина\",\n    \"мэнис\",\n    \"молоканка\",\n    \"буча\",\n    \"молоханка\",\n    \"марка\",\n    \"квадрат\",\n    \"промокашка\",\n    \"мягкий\",\n    \"пластилин\",\n    \"пластид\",\n    \"мякиш\",\n    \"резина\",\n    \"покрышка\",\n    \"пласт\",\n    \"напас\",\n    \"плюха\",\n    \"плюшка\",\n    \"плюшенция\",\n    \"точка\",\n    \"родинка\",\n    \"бумага\",\n    \"сахар\",\n    \"гашиш\",\n    \"гашло\",\n    \"мàцанка\",\n    \"бокш\",\n    \"сыпуха\",\n    \"ширка\",\n    \"химка\",\n    \"лошадь\",\n    \"спартанская\",\n    \"иксовая\",\n    \"спортивная\",\n    \"шмель\",\n    \"шмыга\",\n    \"каша\",\n    \"роготряс\",\n    \"рогиш\",\n    \"рога\",\n    \"аппаратура\",\n    \"отгон\",\n    \"струна\",\n    \"машина\",\n    \"инструмент\",\n    \"боец\",\n    \"баян\",\n    \"чпок\",\n    \"факел\",\n    \"ханки\",\n    \"чек\",\n    \"берушировать\",\n    \"бодяжить\",\n    \"бутором\",\n    \"варить\",\n    \"плюшки\",\n    \"забить\",\n    \"заколотить\",\n    \"заляпать\",\n    \"косяк\",\n    \"кирячнуть\",\n    \"килешануть\",\n    \"табачнуть\",\n    \"растабачить\",\n    \"буторить\",\n    \"разбуторить\",\n    \"бодяга\",\n    \"болт\",\n    \"винта\",\n    \"кислый\",\n    \"компот\",\n    \"красный\",\n    \"нифеля\",\n    \"ботва\",\n    \"дрова\",\n    \"бутор\",\n    \"бошки\",\n    \"бошечки\",\n    \"бохи\",\n    \"шалашка\",\n    \"шалуха\",\n    \"шалва\",\n    \"шалка\",\n    \"пыли\",\n    \"догоняться\",\n    \"юзать\",\n    \"косяк\",\n    \"протинуть\",\n    \"накуриться\",\n    \"раскуриться\",\n    \"дубасить\",\n    \"закинуться\",\n    \"дубаснуть\",\n    \"дунуть\",\n    \"подуть\",\n    \"поддуться\",\n    \"подлечиться\",\n    \"почитать\",\n    \"пыхнуть\",\n    \"хапать\",\n    \"шабить\",\n    \"долбить\",\n    \"нажигать\",\n    \"курнуть\",\n    \"напаснуться\",\n    \"искупиться\",\n    \"обесточиться\",\n    \"закудрявить\",\n    \"убиться\",\n    \"покуряхать\",\n    \"навиталиться\",\n    \"навалериться\",\n    \"хапка\",\n    \"наколотилово\",\n    \"паровоз\",\n    \"парик\",\n    \"паровоза\",\n    \"подлечить\",\n    \"залечить\",\n    \"косяка\",\n    \"бахаться\",\n    \"вмазаться\",\n    \"втюхаться\",\n    \"двинуться\",\n    \"ляпать\",\n    \"ляпнутся\",\n    \"проставляться\",\n    \"пыряться\",\n    \"ставиться\",\n    \"трескаться\",\n    \"ужалиться\",\n    \"хлопнуться\",\n    \"шваркаться\",\n    \"ширяться\",\n    \"шпигаться\",\n    \"винтиться\",\n    \"дома\",\n    \"контроль\",\n    \"клизма\",\n    \"задуть\",\n    \"закинуть\",\n    \"понюхон\",\n    \"зюк\",\n    \"зюкнуть\",\n    \"юзануть\",\n    \"приколоться\",\n    \"фусбалшпилер\",\n    \"банка\",\n    \"баклаха\",\n    \"бульбулятор\",\n    \"буль\",\n    \"булик\",\n    \"бульбик\",\n    \"шмэбл\",\n    \"сухой\",\n    \"батл\",\n    \"баттл\",\n    \"боттл\",\n    \"бульбулятора\",\n    \"бонг\",\n    \"ружье\",\n    \"водный\",\n    \"водник\",\n    \"крыса\",\n    \"хлопушка\",\n    \"хлопарь\",\n    \"котелок\",\n    \"хопчик\",\n    \"пипетка\",\n    \"фошка\",\n    \"колпак\",\n    \"наперсток\",\n    \"напер\",\n    \"крестовик\",\n    \"пайп\",\n    \"костыль\",\n    \"блант\",\n    \"джойнт\",\n    \"штакет\",\n    \"попик\",\n    \"пыж\",\n    \"косяках\",\n    \"штакет\",\n    \"сплиф\",\n    \"урод\",\n    \"агрегат\",\n    \"алберка\",\n    \"лайба\",\n    \"весло\",\n    \"канюля\",\n    \"колючка\",\n    \"петух\",\n    \"смывки\",\n    \"ломки\",\n    \"догнаться\",\n    \"фурик\",\n    \"антенна\",\n    \"алик\",\n    \"аптекарь\",\n    \"бабай\",\n    \"барыга\",\n    \"дилер\",\n    \"пушер\",\n    \"толкач\",\n    \"банчила\",\n    \"фармацевт\",\n    \"знахарь\",\n    \"барыгами\",\n    \"бегунок\",\n    \"берун\",\n    \"гонец\",\n    \"помогала\",\n    \"помогать\",\n    \"скорость\",\n    \"яма\",\n    \"цех\",\n    \"банчить\",\n    \"банковать\",\n    \"подгон\",\n    \"подогрев\",\n    \"грев\",\n    \"взгрев\",\n    \"кинуть\",\n    \"шваркнуть\",\n    \"вымутить\",\n    \"напарить\",\n    \"налечить\",\n    \"пролечить\",\n    \"наездить\",\n    \"абрикос\",\n    \"аппер\",\n    \"абстинент\",\n    \"анашист\",\n    \"бэн\",\n    \"джон\",\n    \"валек\",\n    \"винтовой\",\n    \"выдвиженец\",\n    \"колючий\",\n    \"пырь\",\n    \"космонавт\",\n    \"орешник\",\n    \"психонавт\",\n    \"синий\",\n    \"алкаш\",\n    \"бухарь\",\n    \"синяк\",\n    \"синчер\",\n    \"сливорез\",\n    \"хрон\",\n    \"забулдыга\",\n    \"торчок\",\n    \"торч\",\n    \"укурок\",\n    \"укурыш\",\n    \"хмурящийся\",\n    \"нахмуренный\",\n    \"чернушник\",\n    \"юзер\",\n    \"склиф\",\n    \"диспансер\",\n    \"атама\",\n    \"потушило\",\n    \"мажет\",\n    \"аут\",\n    \"бледный\",\n    \"бэдтрип\",\n    \"бэд\",\n    \"трип\",\n    \"вата\",\n    \"висеть\",\n    \"прихода\",\n    \"ханку\",\n    \"вставляет\",\n    \"зацепило\",\n    \"приход\",\n    \"отпустило\",\n    \"выкупить\",\n    \"спалить\",\n    \"галюники\",\n    \"глюки\",\n    \"голяк\",\n    \"голяки\",\n    \"гонки\",\n    \"зима\",\n    \"системе\",\n    \"измена\",\n    \"кошмарит\",\n    \"кумарить\",\n    \"перекумарить\",\n    \"ломка\",\n    \"козявит\",\n    \"марафон\",\n    \"марафонить\",\n    \"марафоне\",\n    \"приходы\",\n    \"трипы\",\n    \"бэдтрипы\",\n    \"объебос\",\n    \"непонятки\",\n    \"татаходы\",\n    \"обибоз\",\n    \"обибо\",\n    \"подсесть\",\n    \"поздняк\",\n    \"педали\",\n    \"тягой\",\n    \"свин\",\n    \"свинак\",\n    \"снюхаться\",\n    \"сторчаться\",\n    \"торкнуло\",\n    \"колбасит\",\n    \"прет\",\n    \"вставило\",\n    \"штырит\",\n    \"торчать\",\n    \"трип\",\n    \"трухануло\",\n    \"тяга\",\n    \"арык\",\n    \"гепок\",\n    \"дорога\",\n    \"дорожка\",\n    \"колодец\",\n    \"обратка\",\n    \"централка\",\n    \"центряк\",\n    \"синявка\",\n    \"чича\"\n];\n\nmodule.exports = ()=>{\n    return array;\n};","let array = [\n    \"аалоосака\",\n    \"господь\",\n    \"гасподь\",\n    \"аарра\",\n    \"аллаха\",\n    \"абдал\",\n    \"абноба\",\n    \"абраксас\",\n    \"абхасвара\",\n    \"авксесия\",\n    \"австер\",\n    \"агатодемон\",\n    \"агве\",\n    \"агенория\",\n    \"агни\",\n    \"адад\",\n    \"адити\",\n    \"адитьи\",\n    \"адонис\",\n    \"адран\",\n    \"адрастея\",\n    \"аждаак\",\n    \"айаутеотль\",\n    \"айта\",\n    \"айхи\",\n    \"айыы\",\n    \"айыысыт\",\n    \"акедис\",\n    \"акен\",\n    \"акер\",\n    \"акесо\",\n    \"аколмистли\",\n    \"акратопот\",\n    \"алайсиаги\",\n    \"аластор\",\n    \"алекто\",\n    \"аллах\",\n    \"алпан\",\n    \"алфей\",\n    \"ам-хех\",\n    \"аманор\",\n    \"аматэрасу\",\n    \"амаунет\",\n    \"аментет\",\n    \"аменхотеп,\",\n    \"амесеми\",\n    \"амимитль\",\n    \"амон\",\n    \"амонемипет\",\n    \"амфитрита\",\n    \"анаит\",\n    \"анакты\",\n    \"ананке\",\n    \"анат\",\n    \"ангела\",\n    \"андхримнир\",\n    \"анеджти\",\n    \"анигол\",\n    \"анит\",\n    \"аннона\",\n    \"антеворта\",\n    \"антерос\",\n    \"анубис\",\n    \"анукет\",\n    \"анцва\",\n    \"анша\",\n    \"апам\",\n    \"апас\",\n    \"апата\",\n    \"аполлон\",\n    \"апух\",\n    \"арай\",\n    \"арамазд\",\n    \"арга\",\n    \"ардуинна\",\n    \"арев\",\n    \"аренснуфис\",\n    \"ареоп-энап\",\n    \"арес\",\n    \"арета\",\n    \"аристей\",\n    \"аркт\",\n    \"арнакуагсак\",\n    \"арнапкапфаалук\",\n    \"артайус\",\n    \"артемида\",\n    \"артио\",\n    \"аруна\",\n    \"арьяман\",\n    \"асклепий\",\n    \"асоп\",\n    \"астар\",\n    \"астерия\",\n    \"астрей\",\n    \"астрея\",\n    \"астхик\",\n    \"атаргатис\",\n    \"атлант\",\n    \"атлатонин\",\n    \"атлауа\",\n    \"атон\",\n    \"атропос\",\n    \"аттис\",\n    \"атум\",\n    \"ауксо\",\n    \"аура\",\n    \"аурвандил\",\n    \"афина\",\n    \"афродита\",\n    \"афсати\",\n    \"ахелой\",\n    \"ахурамазда\",\n    \"ашвины\",\n    \"ашера\",\n    \"ашшур\",\n    \"баал\",\n    \"баба\",\n    \"баби\",\n    \"бадб\",\n    \"баларама\",\n    \"бальдр\",\n    \"бангпутис\",\n    \"банебджедет\",\n    \"барон\",\n    \"баршамин\",\n    \"басилея\",\n    \"баст\",\n    \"бата\",\n    \"белен\",\n    \"беллона\",\n    \"бенну\",\n    \"биби\",\n    \"бисямонтэн\",\n    \"благая\",\n    \"борей\",\n    \"браги\",\n    \"брахма\",\n    \"бригита\",\n    \"бритомартида\",\n    \"брихаспати\",\n    \"будте\",\n    \"бури\",\n    \"бхага\",\n    \"бхубанешвари\",\n    \"бхуми\",\n    \"бэндзайтэн\",\n    \"ваагн\",\n    \"вагитан\",\n    \"ваджрасаттва\",\n    \"вали\",\n    \"вамана\",\n    \"вамматар\",\n    \"вант\",\n    \"вараха\",\n    \"варуна\",\n    \"варуни\",\n    \"васу\",\n    \"вата\",\n    \"велес\",\n    \"велняс\",\n    \"велс\",\n    \"велунд\",\n    \"венег\",\n    \"венера\",\n    \"вентшукумишитеу\",\n    \"верпея\",\n    \"веста\",\n    \"вивасват\",\n    \"видар\",\n    \"вика\",\n    \"вили\",\n    \"виракоча\",\n    \"вишвакарман\",\n    \"вишведевы\",\n    \"вишну\",\n    \"войпель\",\n    \"волгенче\",\n    \"волупия\",\n    \"вольтумна\",\n    \"гана\",\n    \"ганеша\",\n    \"гармахис\",\n    \"гарпократ\",\n    \"гвидион\",\n    \"геба\",\n    \"гебелейзис\",\n    \"гевьон\",\n    \"геде\",\n    \"геката\",\n    \"гела\",\n    \"гелиады\",\n    \"гелиос\",\n    \"гемера\",\n    \"гера\",\n    \"герас\",\n    \"германубис\",\n    \"гермес\",\n    \"гермес\",\n    \"геспер\",\n    \"гестия\",\n    \"гефест\",\n    \"гибрис\",\n    \"гибрис\",\n    \"гигиея\",\n    \"гименей\",\n    \"гимерос\",\n    \"гиперион\",\n    \"гипериониды\",\n    \"гипнос\",\n    \"гисане\",\n    \"главк\",\n    \"гликон\",\n    \"глин\",\n    \"гоибниу\",\n    \"гор-ахти\",\n    \"грох\",\n    \"дагда\",\n    \"дажьбог\",\n    \"дайкокутэн\",\n    \"дакша\",\n    \"дана\",\n    \"даттатрея\",\n    \"даша\",\n    \"дашамахавидья\",\n    \"дедун\",\n    \"деймос\",\n    \"деллинг\",\n    \"деметр\",\n    \"деметра\",\n    \"демос\",\n    \"деспина\",\n    \"децима\",\n    \"джесегей\",\n    \"дзюродзин\",\n    \"диан\",\n    \"диана\",\n    \"дике\",\n    \"диона\",\n    \"дионис\",\n    \"дити\",\n    \"дорида\",\n    \"дуамутеф\",\n    \"дурга\",\n    \"дханвантари\",\n    \"дьайачы\",\n    \"дьайык\",\n    \"еврибия\",\n    \"елта\",\n    \"жемепатис\",\n    \"жива\",\n    \"забаба\",\n    \"загрей\",\n    \"залмоксис\",\n    \"затик\",\n    \"зевс\",\n    \"земес-мате\",\n    \"зефир\",\n    \"зу-ль-халаса\",\n    \"иапет\",\n    \"иасо\",\n    \"идзанаги\",\n    \"идзанами\",\n    \"идофея\",\n    \"идунн\",\n    \"иегова\",\n    \"иламатекутли\",\n    \"илифия\",\n    \"илыш-шочын-ава\",\n    \"ильмаринен\",\n    \"ильматар\",\n    \"имир\",\n    \"имиут\",\n    \"имхотеп\",\n    \"инанна\",\n    \"инах\",\n    \"инву\",\n    \"индра\",\n    \"инйан\",\n    \"инмар\",\n    \"инти\",\n    \"иншушинак\",\n    \"ипет-хемет\",\n    \"ирида\",\n    \"исида\",\n    \"исимуд\",\n    \"исмен\",\n    \"истанус\",\n    \"иунит\",\n    \"ицамна\",\n    \"ицпапалотль\",\n    \"иш-чель\",\n    \"ишкур\",\n    \"иштар\",\n    \"иштаран\",\n    \"иштлильтон\",\n    \"иэйиэхсит\",\n    \"йемайя\",\n    \"йома\",\n    \"йомшоэнгер\",\n    \"кабиры\",\n    \"кавильяке\",\n    \"кадеш\",\n    \"каистр\",\n    \"кайракан\",\n    \"кайрос\",\n    \"кала\",\n    \"кали\",\n    \"калки\",\n    \"кама\",\n    \"камаштли\",\n    \"камрусепа\",\n    \"камул\",\n    \"кане\",\n    \"капитолийская\",\n    \"карачун\",\n    \"кармента\",\n    \"карпос\",\n    \"каршит\",\n    \"квирин\",\n    \"кебехсенуф\",\n    \"кебрен\",\n    \"кепе\",\n    \"кернунн\",\n    \"керы\",\n    \"кето\",\n    \"кетцалькоатль\",\n    \"кефис\",\n    \"кефисс\",\n    \"кече\",\n    \"кече\",\n    \"кибела\",\n    \"кисимодзин\",\n    \"клеменция\",\n    \"клиодна\",\n    \"клото\",\n    \"коатликуэ\",\n    \"кожла\",\n    \"койольшауки\",\n    \"кокопелли\",\n    \"конкордия\",\n    \"конс\",\n    \"косихо-питао\",\n    \"котис\",\n    \"коча-кан\",\n    \"кратос\",\n    \"крий\",\n    \"кринис\",\n    \"криофор\",\n    \"кришна\",\n    \"кронос\",\n    \"куазь\",\n    \"кубера\",\n    \"кугу-юмо\",\n    \"кугуен\",\n    \"кудай\",\n    \"кукарка\",\n    \"кукулькан\",\n    \"кукумац\",\n    \"курма\",\n    \"курык\",\n    \"кусинада-химэ\",\n    \"кылдысин\",\n    \"лаас\",\n    \"лаверна\",\n    \"лазы\",\n    \"лакшми\",\n    \"лары\",\n    \"лахесис\",\n    \"левана\",\n    \"левкофея\",\n    \"лето\",\n    \"либертас\",\n    \"лисса\",\n    \"литы\",\n    \"ло-цзу\",\n    \"локи\",\n    \"луна\",\n    \"лусин\",\n    \"маат\",\n    \"маахес\",\n    \"магни\",\n    \"майдере\",\n    \"майяуаль\",\n    \"макрида\",\n    \"малик\",\n    \"малинальшочи\",\n    \"мама\",\n    \"мама\",\n    \"мананнан\",\n    \"манат\",\n    \"мангала\",\n    \"мандулис\",\n    \"мани\",\n    \"мания\",\n    \"мардеж-ава\",\n    \"мардук\",\n    \"мариамман\",\n    \"марс\",\n    \"маруты\",\n    \"матаришван\",\n    \"матрики\",\n    \"матсья\",\n    \"мать\",\n    \"мауи\",\n    \"мафдет\",\n    \"махахеф\",\n    \"махуика\",\n    \"мгла\",\n    \"мегера\",\n    \"медейна\",\n    \"менетий\",\n    \"меримутеф\",\n    \"меритсегер\",\n    \"меркурий\",\n    \"месхенет\",\n    \"метида\",\n    \"мехен\",\n    \"мецтли\",\n    \"мештли\",\n    \"миктлантекутли\",\n    \"минерва\",\n    \"митра\",\n    \"миха-нана\",\n    \"михр\",\n    \"мишкоатль\",\n    \"мланде-ава\",\n    \"мневис\",\n    \"мнемосина\",\n    \"моди\",\n    \"мойры\",\n    \"мокошь\",\n    \"молох\",\n    \"монту\",\n    \"морриган\",\n    \"морта\",\n    \"морфей\",\n    \"мохини\",\n    \"музы\",\n    \"мусо\",\n    \"набу\",\n    \"намму\",\n    \"нанауацин\",\n    \"нане\",\n    \"нанна\",\n    \"нанук\",\n    \"нара-нараяна\",\n    \"нарасимха\",\n    \"небтуи\",\n    \"нейт\",\n    \"немайн\",\n    \"немда\",\n    \"немезида\",\n    \"немти\",\n    \"непобедимое\",\n    \"непри\",\n    \"нептун\",\n    \"нергал\",\n    \"нерей\",\n    \"нерио\",\n    \"нерривик\",\n    \"нерта\",\n    \"нефертум\",\n    \"нефтида\",\n    \"нехбет\",\n    \"нехебкау\",\n    \"ника\",\n    \"ниназу\",\n    \"нингирсу\",\n    \"нингишзида\",\n    \"нинсун\",\n    \"нинурта\",\n    \"нисаба\",\n    \"нона\",\n    \"норны\",\n    \"норция\",\n    \"нотт\",\n    \"нуаду\",\n    \"нумушда\",\n    \"нуску\",\n    \"ньерд\",\n    \"нюкта\",\n    \"огма\",\n    \"огун\",\n    \"один\",\n    \"ойзис\",\n    \"окунинуси\",\n    \"омакатль\",\n    \"ометеотль\",\n    \"онар\",\n    \"онир\",\n    \"онурис\",\n    \"опочтли\",\n    \"оркус\",\n    \"осирис\",\n    \"от-эне\",\n    \"офион\",\n    \"ошмазик\",\n    \"пайналь\",\n    \"палики\",\n    \"паллант\",\n    \"панакея\",\n    \"пандия\",\n    \"пандроса\",\n    \"папа\",\n    \"парашурама\",\n    \"парвати\",\n    \"парджанья\",\n    \"парки\",\n    \"патекатль\",\n    \"пахт\",\n    \"пача\",\n    \"пачамама\",\n    \"пашупати\",\n    \"пеан\",\n    \"пейто\",\n    \"пеле\",\n    \"пенаты\",\n    \"пеней\",\n    \"перкунас\",\n    \"перс\",\n    \"персефона\",\n    \"перун\",\n    \"пизюс\",\n    \"пикумн\",\n    \"пилумн\",\n    \"пильвитс\",\n    \"пирва\",\n    \"питао-кособи\",\n    \"плутос\",\n    \"подага\",\n    \"понос\",\n    \"понт\",\n    \"поренут\",\n    \"порос\",\n    \"портун\",\n    \"посейдон\",\n    \"постворта\",\n    \"потос\",\n    \"праджапати\",\n    \"праксидика\",\n    \"приап\",\n    \"притху\",\n    \"пришнигарбха\",\n    \"прометей\",\n    \"протей\",\n    \"психея\",\n    \"птах\",\n    \"пулех\",\n    \"пулугу\",\n    \"пушан\",\n    \"пыл-ава\",\n    \"ра-хорахте\",\n    \"рама\",\n    \"исус\",\n    \"иссус\",\n    \"исусс\",\n    \"алах\",\n    \"аллах\",\n    \"иисус\",\n    \"рат-тауи\",\n    \"рати\",\n    \"рененутет\",\n    \"рехуа\",\n    \"рианнон\",\n    \"рибху\",\n    \"ринд\",\n    \"ришабха\",\n    \"ро’о-и-те-хиропои\",\n    \"рогатый\",\n    \"рома\",\n    \"ронго\",\n    \"руаумоко\",\n    \"ругевит\",\n    \"рудра\",\n    \"сабазий\",\n    \"савитар\",\n    \"сага\",\n    \"салация\",\n    \"салюс\",\n    \"сарасвати\",\n    \"сатис\",\n    \"сатурн\",\n    \"сварог\",\n    \"сварожич\",\n    \"святовит\",\n    \"себек\",\n    \"себектет\",\n    \"себуимекер\",\n    \"седна\",\n    \"селена\",\n    \"селкет\",\n    \"сельванс\",\n    \"семь\",\n    \"сенцонуицнауа\",\n    \"серапис\",\n    \"сехмет\",\n    \"сешат\",\n    \"сигюн\",\n    \"силен\",\n    \"силены\",\n    \"симаргл\",\n    \"сипактли\",\n    \"сита\",\n    \"ситлалатонак\",\n    \"ситлаликуэ\",\n    \"сиуакоатль\",\n    \"скамандр\",\n    \"сканда\",\n    \"скотос\",\n    \"снотра\",\n    \"сокар\",\n    \"соль\",\n    \"сопдет\",\n    \"сопду\",\n    \"сперхей\",\n    \"спес\",\n    \"спорыш\",\n    \"сумман\",\n    \"супай\",\n    \"сура\",\n    \"сурья\",\n    \"сусаноо\",\n    \"сюгэ\",\n    \"та’ароа\",\n    \"таара\",\n    \"тавмант\",\n    \"тай-суй\",\n    \"талос\",\n    \"таммуз\",\n    \"танатос\",\n    \"тангароа\",\n    \"тане\",\n    \"танунапат\",\n    \"тара\",\n    \"таранис\",\n    \"таргитай\",\n    \"тарку\",\n    \"татенен\",\n    \"таурт\",\n    \"тафириматеа\",\n    \"тваштар\",\n    \"тевтат\",\n    \"тейшеба\",\n    \"тексистекатль\",\n    \"телепину\",\n    \"телесфор\",\n    \"теллус\",\n    \"тенгри\",\n    \"тенему\",\n    \"тененет\",\n    \"теояомкуи\",\n    \"тепейоллотль\",\n    \"термин\",\n    \"тескатлипока\",\n    \"тефида\",\n    \"тефнут\",\n    \"тешуб\",\n    \"тисифона\",\n    \"тиште-юмо\",\n    \"тлалок\",\n    \"тлальтекутли\",\n    \"тласолтеотль\",\n    \"тлоке\",\n    \"тоетама-химэ\",\n    \"тоеукэ\",\n    \"тонанцин\",\n    \"тонатиу\",\n    \"торк\",\n    \"тоси\",\n    \"тридеви\",\n    \"тримурти\",\n    \"трипурасундари\",\n    \"трита\",\n    \"тритон\",\n    \"тритопатры\",\n    \"труд\",\n    \"тул-ава\",\n    \"туматауэнга\",\n    \"тура\",\n    \"туран\",\n    \"туту\",\n    \"тылызе\",\n    \"тэндзин\",\n    \"тюхе\",\n    \"уаджит\",\n    \"ужара\",\n    \"уицилопочтли\",\n    \"уиштосиуатль\",\n    \"укко\",\n    \"улль\",\n    \"ульгень\",\n    \"умай\",\n    \"унут\",\n    \"упуаут\",\n    \"уран\",\n    \"усоос\",\n    \"ушас\",\n    \"уэнуку\",\n    \"уэуэкойотль\",\n    \"уэуэтеотль\",\n    \"фавн\",\n    \"фаитири\",\n    \"фанет\",\n    \"фантас\",\n    \"фаро\",\n    \"феба\",\n    \"фебруус\",\n    \"фекундитас\",\n    \"фемида\",\n    \"фобетор\",\n    \"фобос\",\n    \"форкий\",\n    \"форсети\",\n    \"фортуна\",\n    \"фосфор\",\n    \"фрейр\",\n    \"фтон\",\n    \"фукурокудзю\",\n    \"фулла\",\n    \"фуфлунс\",\n    \"хавбас\",\n    \"халди\",\n    \"хамос\",\n    \"хануман\",\n    \"хаома\",\n    \"хапи\",\n    \"хапи\",\n    \"харон\",\n    \"хатмехит\",\n    \"хатхор\",\n    \"хаумеа\",\n    \"хаумиа-тикетике\",\n    \"хаухет\",\n    \"хаягрива\",\n    \"хеваджра\",\n    \"хеймдалль\",\n    \"хейока\",\n    \"хекат\",\n    \"хенир\",\n    \"хепри\",\n    \"херишеф\",\n    \"хермод\",\n    \"хина\",\n    \"хине-нуи-те-по\",\n    \"хлорида\",\n    \"хнум\",\n    \"хнум-ра\",\n    \"хонсу\",\n    \"хормуста\",\n    \"хорс\",\n    \"хронос\",\n    \"хуарун\",\n    \"хубал\",\n    \"хумпан\",\n    \"хуракан\",\n    \"центеотль\",\n    \"церера\",\n    \"цероклис\",\n    \"цинуарди\",\n    \"цовинар\",\n    \"цукиеми\",\n    \"чальчиутликуэ\",\n    \"чамунда\",\n    \"чанди\",\n    \"чандра\",\n    \"чантико\",\n    \"чернобог\",\n    \"чжан-сянь\",\n    \"чжи-нюй\",\n    \"чимальма\",\n    \"шакти\",\n    \"шамаш\",\n    \"шезметет\",\n    \"шезму\",\n    \"шеларди\",\n    \"шива\",\n    \"шивини\",\n    \"шилонен\",\n    \"шиутекутли\",\n    \"шочипилли\",\n    \"шудыр\",\n    \"шульпае\",\n    \"эагр\",\n    \"эбису\",\n    \"эвномия\",\n    \"эекатль\",\n    \"эзус\",\n    \"эк-чуах\",\n    \"элохим\",\n    \"эниалий\",\n    \"энио\",\n    \"энипей\",\n    \"энлиль\",\n    \"энмешарр\",\n    \"эпимелиды\",\n    \"эпиметей\",\n    \"эпиона\",\n    \"эпона\",\n    \"эреб\",\n    \"эрешкигаль\",\n    \"эрзули\",\n    \"эрзули\",\n    \"эридан\",\n    \"эринии\",\n    \"эриу\",\n    \"эрлик\",\n    \"эрот\",\n    \"эроты\",\n    \"эрра\",\n    \"эрса\",\n    \"эфир\",\n    \"эфон\",\n    \"юмала\",\n    \"юмис\",\n    \"юмын\",\n    \"юмын\",\n    \"юнона\",\n    \"юпитер\",\n    \"юрюнг\",\n    \"юстиция\",\n    \"якатекутли\",\n    \"янус\",\n    \"ярила\",\n    \"яровит\",\n    \"яхве\",\n    \"бог\",\n    \"бога\",\n    \"богородица\",\n    \"богародица\"\n];\n\nmodule.exports = ()=>{\n    return array;\n}","let array = [\n    'хохол',\n    'хохлы',\n    'хохлушка',\n    'чурка',\n    'черножопый',\n    'чурки',\n    'черножопые',\n    'салоед',\n    'салоеды',\n    'бульбаш',\n    'бульбаши',\n    'бульбашка',\n    'пшек',\n    'пшеки'\n];\n\nmodule.exports = ()=>{\n    return array;\n}","let Az = require('az');\nconst swear = require(\"./dicts/swear\")(true);\nconst drags = require(\"./dicts/drags\")();\nconst gods = require(\"./dicts/gods\")();\nconst racism = require(\"./dicts/racism\")();\n\nlet UNIQ_MARKERS = false;\nlet TRIGGERS = [];\nlet sentence_seq = [];\nlet AzInitiated = false;\n\n\n/**\n * Метод анализа строк\n * @param {string} sentence Строка для анализа\n * @returns {Object} Объект результатов анализа\n */\nfunction Analysis(sentence){\n    // if(!AzInitiated) return sentence_seq.push(sentence);\n    if(!AzInitiated){\n        return new Promise(function (resolve, reject) {\n            sentence_seq.push(function(params) {\n                return resolve(Analysis(sentence));\n            })\n        });\n    }\n\n    // Разделение текста на предложения\n    let sentences = sentence.replace(/\\.\\.(\\.*)/g, '.').replace(/([.?!\\n])\\s*(?=[\\D])/g, \"$1|\").split(\"|\");\n    let sentences_tokens = [];\n    for(let s of sentences) sentences_tokens.push( new Az.Tokens(s).done().filter(x=>x.type==\"WORD\") );\n    \n    // Генерация морфем и их свойств по словам в предложениях\n    let marker_collection = [];\n    let triggered_collection = [];\n    let sentences_morphs = [];\n    for(let sentence_tokens of sentences_tokens){\n        let sentence_morphs = [];\n        for(let token of sentence_tokens){\n            let morph = Az.Morph(token.toString());\n            let morph_POST = \"undf\";\n            if(morph.length != 0) morph_POST = morph[0].tag.POST;\n            let text = token.toString().toLowerCase();\n            let is_drags = false;\n            let is_swear = false;\n            let is_god = false;\n            let is_dangerous_people = false;\n            let is_racism = false;\n            if(swear.includes(text.replace(/ё/g, 'е'))) is_swear = true;\n            if(drags.includes(text.replace(/ё/g, 'е'))) is_drags = true;\n            if(gods.includes(text.replace(/ё/g, 'е'))) is_god = true;\n            if(racism.includes(text.replace(/ё/g, 'е'))) is_racism = true;\n            sentence_morphs.push( {\n                ...token,\n                POST: morph_POST, \n                text, \n                normalized: morph[0]?(morph[0].normalize(false).word||text):text,\n                is_drags, \n                is_god, \n                is_swear, \n                is_dangerous_people, \n                is_racism\n            } );\n        }\n        sentences_morphs.push(sentence_morphs);\n    }\n\n    let all_morphs = [].concat.apply([],sentences_morphs)\n\n    // Обработка всех возможных тригеров\n    for(let trigger of TRIGGERS){\n        if(trigger.no_words_like_this) continue;\n        switch (trigger.check_scope) {\n            case \"sentences\":\n                for(let sentence_morphs of sentences_morphs) {\n                    let check = CheckMorphsForTriggers({sentence_morphs, trigger});\n                    marker_collection.push( ...check.markers );\n                    triggered_collection.push( ...check.triggered );\n                }\n                continue;\n            default:\n                let check = CheckMorphsForTriggers({sentence_morphs: all_morphs, trigger});\n                marker_collection.push( ...check.markers );\n                triggered_collection.push( ...check.triggered );\n                continue;\n        }\n    }\n    \n    // Анализ всего текста на отсутсвие запрещенных сочитаний\n    for(let trigger of TRIGGERS.filter(x=>x.no_words_like_this)){\n        if(trigger.no_words_like_this){\n            for(let nw of trigger.no_words_like_this){\n                if(sentence.toLowerCase().includes(nw)){\n                    marker_collection.push(...trigger.markers);\n                }\n            }\n        }\n    }\n\n    if(UNIQ_MARKERS) marker_collection = marker_collection.filter((v,i,a)=>a.findIndex(t=>(t === v))===i);\n\n    // Результат\n    return {\n        sentence,\n        sentences,\n        markers: marker_collection,\n        triggered: triggered_collection,\n        morphs: sentences_morphs\n    }\n}\n\n\n/**\n * Проверка последовательности морфем на тригеры\n * @param {Object} param0\n * @param {Array} param0.sentence_morphs Массив морфем\n * @param {Object} param0.trigger Тригер для проверки\n * @param {Boolean=} param0.strict_word_sequence Проверка соблюдения последовательности морфем относительно правил в тригере\n * @returns {Object} Объект маркеров и тригеров\n */\nfunction CheckMorphsForTriggers({sentence_morphs, trigger}){\n    let markers_collection = [];\n    let triggered = [];\n    if(trigger.strict_word_sequence) trigger.strict_word_direction = true;\n\n    if(trigger.strict_word_direction){\n        let a = trigger.words;\n        let b = sentence_morphs;\n        //...\n        let m = 0;\n        for(let _b of b){\n            let _a = a[m];\n            \n            let a_keys = Object.keys(_a);\n            let b_keys = Object.keys(_b);\n            for(let b_key of b_keys) a_keys = a_keys.filter(x=>x!=b_key);\n            if(a_keys.length != 0) continue;\n            \n            let keys_to_check = Object.keys(_a);\n            let valid_keys = 0;\n            let need_valid_keys = keys_to_check.length;\n            \n            for(let key of keys_to_check){\n                if(key === \"text\"){\n                    let values = typeof _a[key] == \"string\"?[_a[key]]:_a[key];\n                    if(values.includes(_b[key])) valid_keys++;\n                    continue;\n                }\n                if(key === \"normalized\"){\n                    let values = typeof _a[key] == \"string\"?[_a[key]]:_a[key];\n                    if(values.includes(_b[key])) valid_keys++;\n                    continue;\n                }\n                if(_a[key]===_b[key]) valid_keys++;\n            }\n            if(valid_keys == need_valid_keys){\n                m++;\n                if(m == a.length) break;\n            }else{\n                if(trigger.strict_word_sequence) m = 0;\n            }\n        }\n        if(m == a.length) {\n            markers_collection.push(...trigger.markers)\n            triggered.push(trigger);\n        }\n    }else{\n        let a = trigger.words;\n        let b = sentence_morphs;\n        let m = 0;\n        for(let _a of a){\n            for(let _b of b){\n                let keys_to_check = Object.keys(_a);\n                let valid_keys = 0;\n                let need_valid_keys = keys_to_check.length;\n                for(let key of keys_to_check){\n                    if(key === \"text\"){\n                        let values = typeof _a[key] == \"string\"?[_a[key]]:_a[key];\n                        if(values.includes(_b[key])) valid_keys++;\n                        continue;\n                    }\n                    if(key === \"normalized\"){\n                        let values = typeof _a[key] == \"string\"?[_a[key]]:_a[key];\n                        if(values.includes(_b[key])) valid_keys++;\n                        continue;\n                    }\n                    if(_a[key]===_b[key]) valid_keys++;\n                }\n                if(valid_keys == need_valid_keys){\n                    m++;\n                }\n            }\n        }\n        if(m == a.length) {\n            markers_collection.push(...trigger.markers)\n            triggered.push(trigger);\n        }\n    }\n    return {markers: markers_collection, triggered};\n}\n\n\n\n/**\n * Инициализация процессора обработки натурального языка\n * @param {Object} params \n * @param {Array=} params.triggers Словарь тригеров\n * @param {Boolean=} params.uniq_markers Возвращать маркеры без повторов [1,1,1]->[1]\n * @param {any=} params.loadedAz Собственный Az с предзагруженными словарями\n * @returns {Function} Метод анализа строк\n */\nlet Init = function({triggers=[], uniq_markers=false, loadedAz=null}){\n    TRIGGERS = triggers;\n    UNIQ_MARKERS = uniq_markers;\n    if(loadedAz){\n        AzInitiated = true;\n        Az = loadedAz;\n        return Analysis;\n    }\n    Az.Morph.init('./node_modules/az/dicts', function(){\n        AzInitiated = true;\n        for(let resolveAnalysis of sentence_seq) {\n            sentence_seq = sentence_seq.slice(1);\n            resolveAnalysis();\n        }\n\n    });\n    return Analysis;\n};\n\nmodule.exports = Init;"]}